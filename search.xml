<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>node.js 调试方法</title>
      <link href="/2019/02/27/node-js-%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
      <url>/2019/02/27/node-js-%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="使用chome-devtool调试"><a href="#使用chome-devtool调试" class="headerlink" title="使用chome-devtool调试"></a>使用chome-devtool调试</h1><h2 id="调试node服务"><a href="#调试node服务" class="headerlink" title="调试node服务"></a>调试node服务</h2><h3 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir nodeDebug</span><br><span class="line">cd nodeDebug</span><br><span class="line">npm init</span><br><span class="line">npm i express</span><br><span class="line">touch server.js</span><br></pre></td></tr></table></figure><blockquote><p>编辑server.js文件，写入以下内容</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const app = require(&apos;express&apos;)();</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;,(req,res)=&gt;&#123;</span><br><span class="line">    res.send(&apos;hello&apos;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure><h3 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h3><blockquote><p>node –inspect server.js //不指定调试端口，默认9229<br>node –inspect=9999 server.js //指定调试端口</p></blockquote><h3 id="访问服务"><a href="#访问服务" class="headerlink" title="访问服务"></a>访问服务</h3><p>在浏览器中打开localhost:3000,页面返回helo，说明服务启动成功。<br>打开控制台会发现有node标志，点击即可进入node代码调试。</p><p><img src="/img/nodeDebug/debug1.png" alt=""></p><p>此时添加断点，再次访问localhost:3000,即可进入该服务进行断点调试。</p><p><img src="/img/nodeDebug/debug2.png" alt=""></p><h2 id="调试非服务代码"><a href="#调试非服务代码" class="headerlink" title="调试非服务代码"></a>调试非服务代码</h2><h3 id="准备步骤-1"><a href="#准备步骤-1" class="headerlink" title="准备步骤"></a>准备步骤</h3><blockquote><p>index.js</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">let b = 2;</span><br><span class="line"></span><br><span class="line">function add(a,b)&#123;</span><br><span class="line">    return a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(a,b);</span><br></pre></td></tr></table></figure><h3 id="启动调试-1"><a href="#启动调试-1" class="headerlink" title="启动调试"></a>启动调试</h3><blockquote><p>node –inspect-brk server.js //不指定调试端口，默认9229<br>node –inspect-brk=9999 server.js //指定调试端口</p></blockquote><p>注意命令的变化，此时改用<b>–inspect-brk</b>命令打开调试。如果直接使用–inspect命令，由于此时代码中没有断点，代码运行结束即调试结束，这个过程是很快的，没有办法像服务那样通过再次访问来切入调试。<br><b>–inspect-brk</b>命令会默认在第一行加入断点，等待继续调试。</p><h3 id="打开chrome-devtool"><a href="#打开chrome-devtool" class="headerlink" title="打开chrome-devtool"></a>打开chrome-devtool</h3><blockquote><p>在浏览器输入 chrome://inspect 进入谷歌调试</p></blockquote><p><img src="/img/nodeDebug/debug3.png" alt=""></p><blockquote><p>点击configure</p></blockquote><p><img src="/img/nodeDebug/debug4.png" alt=""></p><p>添加调试的ip和端口,然后点击<b>inspect</b>进入调试。</p><p><img src="/img/nodeDebug/debug5.png" alt=""></p><p>此时的断点在第一行等待。</p><p><img src="/img/nodeDebug/debug6.png" alt=""></p><h1 id="使用vscode调试"><a href="#使用vscode调试" class="headerlink" title="使用vscode调试"></a>使用vscode调试</h1><blockquote><p>添加node debug插件到编辑器</p></blockquote><p><img src="/img/nodeDebug/debug7.png" alt=""></p><blockquote><p>进入vscode调试面板</p></blockquote><p><img src="/img/nodeDebug/debug8.png" alt=""></p><blockquote><p>添加node调试配置</p></blockquote><p><img src="/img/nodeDebug/debug9.png" alt=""></p><blockquote><p>添加断点，点击调试</p></blockquote><p><img src="/img/nodeDebug/debug10.png" alt=""></p><h1 id="使用命令行调试"><a href="#使用命令行调试" class="headerlink" title="使用命令行调试"></a>使用命令行调试</h1><p>官方提供了详细的说明，不赘述</p><p><a href="http://nodejs.cn/api/debugger.html" target="_blank" rel="noopener">文档链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eslint使用教程</title>
      <link href="/2019/02/15/eslint%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2019/02/15/eslint%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>检查语法错误</li><li>检查语法风格</li><li>修正语法</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//项目内安装</span><br><span class="line">npm i -D eslint</span><br><span class="line"></span><br><span class="line">//全局安装</span><br><span class="line">npm i -g eslint</span><br></pre></td></tr></table></figure><h2 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint --init</span><br></pre></td></tr></table></figure><p>运行该命令将会在目录下生成一个.eslintrc(.js|.json|.yml)文件，该文件就是eslint规则的配置文件</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;semi&quot;: [&quot;error&quot;, &quot;always&quot;],</span><br><span class="line">        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“semi”和”quotes”就是ESLint中的配置规则名，[“error”, “always”]和[“error”, “double”]就是对应的配置，”error”参数代表该规则的错误等级，该等级有”off”,”warn”,”error”三种。”always”和”double”则是具体的配置项。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;env&quot;: &#123;</span><br><span class="line">        &quot;browser&quot;: true,</span><br><span class="line">        &quot;node&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可配置的环境还有:</p><ul><li>browser - 浏览器全局变量。</li><li>node - Node.js全局变量和Node.js范围。</li><li>commonjs - CommonJS全局变量和CommonJS范围（将此用于使用Browserify / WebPack的仅浏览器代码）。</li><li>shared-node-browser - Node.js和Browser共有的全局变量。</li><li>es6- 启用除模块之外的所有ECMAScript 6功能（这会自动将ecmaVersion解析器选项设置为6）。</li><li>worker - worker全局变量。</li><li>amd- 根据amd规范定义require()和define()作为全局变量。</li><li>mocha - 添加所有Mocha测试全局变量。</li><li>jasmine - 为版本1.3和2.0添加了所有Jasmine测试全局变量。</li><li>jest - Jest全局变量。</li><li>phantomjs - PhantomJS全局变量。</li><li>protractor - Protractor全局变量。</li><li>qunit - QUnit全局变量。</li><li>jquery - jQuery全局变量。</li><li>prototypejs - Prototype.js全局变量。</li><li>shelljs - ShellJS全局变量。</li><li>meteor - meteor全球变量。</li><li>mongo - MongoDB全局变量。</li><li>applescript - AppleScript全局变量。</li><li>nashorn - Java 8 Nashorn全局变量。</li><li>serviceworker - serviceworker全局变量。</li><li>atomtest - atom test辅助全局变量。</li><li>embertest - Ember测试辅助全局变量。</li><li>webextensions - WebExtensions全局变量。</li><li>greasemonkey - GreaseMonkey全局变量。</li></ul><h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;plugin1&quot;,</span><br><span class="line">        &quot;eslint-plugin-plugin2&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="让一组文件不接受规则校验"><a href="#让一组文件不接受规则校验" class="headerlink" title="让一组文件不接受规则校验"></a>让一组文件不接受规则校验</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;rules&quot;: &#123;...&#125;,</span><br><span class="line">  &quot;overrides&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;files&quot;: [&quot;*-test.js&quot;,&quot;*.spec.js&quot;],</span><br><span class="line">      &quot;rules&quot;: &#123;</span><br><span class="line">        &quot;no-unused-expressions&quot;: &quot;off&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="忽略一些文件"><a href="#忽略一些文件" class="headerlink" title="忽略一些文件"></a>忽略一些文件</h2><p>需要添加.eslintignore,内容格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">**/*.js</span><br><span class="line">**/*.js</span><br><span class="line">**/*.js</span><br><span class="line">**/*.js</span><br></pre></td></tr></table></figure><h2 id="配置扩展文件"><a href="#配置扩展文件" class="headerlink" title="配置扩展文件"></a>配置扩展文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;rules&quot;:&#123;...&#125;,</span><br><span class="line">    &quot;extends&quot;:&quot;airbnb-base&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rules中的规则会覆盖扩展中的规则</p><h1 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h1><p>在全局安装的情况下，可以使用eslint命令行</p><h2 id="校验文件"><a href="#校验文件" class="headerlink" title="校验文件"></a>校验文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint file.js</span><br></pre></td></tr></table></figure><h2 id="指定配置文件"><a href="#指定配置文件" class="headerlink" title="指定配置文件"></a>指定配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint -c myconfig file.js</span><br></pre></td></tr></table></figure><h2 id="修复语法"><a href="#修复语法" class="headerlink" title="修复语法"></a>修复语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint --fix file.js</span><br></pre></td></tr></table></figure><h2 id="将错误报告输出"><a href="#将错误报告输出" class="headerlink" title="将错误报告输出"></a>将错误报告输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint -f html file.js -o out.html</span><br></pre></td></tr></table></figure><p>-o: 输出文件名<br>-f: 输出文件格式</p><p>可接受格式有:</p><ul><li>checkstyle</li><li>codeframe</li><li>compact</li><li>html</li><li>jslint-xml</li><li>json</li><li>junit</li><li>stylish (the default)</li><li>table</li><li>tap</li><li>unix</li><li>visualstudio</li></ul><h2 id="有色输出"><a href="#有色输出" class="headerlink" title="有色输出"></a>有色输出</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint --color file.js</span><br></pre></td></tr></table></figure><h2 id="添加缓存"><a href="#添加缓存" class="headerlink" title="添加缓存"></a>添加缓存</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint --cache file.js</span><br></pre></td></tr></table></figure><p>会记录已经校验过的文件，优化eslint性能</p><h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><p>见官网:<a href="https://eslint.org/docs/rules/" target="_blank" rel="noopener">https://eslint.org/docs/rules/</a></p><h1 id="扩展推荐"><a href="#扩展推荐" class="headerlink" title="扩展推荐"></a>扩展推荐</h1><ul><li>eslint-config-airbnb-base</li><li>eslint-config-standard</li><li>eslint-config-alloy</li><li>eslint-config-google</li><li>eslint-config-prettier</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端开发工具 </tag>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>centOS 最小化安装入坑实践</title>
      <link href="/2019/02/02/centOS-%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%89%E8%A3%85%E5%85%A5%E5%9D%91%E5%AE%9E%E8%B7%B5/"/>
      <url>/2019/02/02/centOS-%E6%9C%80%E5%B0%8F%E5%8C%96%E5%AE%89%E8%A3%85%E5%85%A5%E5%9D%91%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<p>CentOS在安装过程中会让你选择是否需要一键安装相应的包，例如X window软件，运行环境：java，python等，服务器软件：邮件服务器，ftp服务器等；安装这些包通常会使安装过程变长，想要得到最快速的安装体验，当然是选择最小化安装centOS，这样系统不会安装任何多余的包，安装速度也变得更快。</p><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><p>但是在最小化安装完成之后会发现，你更本没有办法安装软件。<br>这是因为centOS最小化安装是不会启动你的网卡！！！</p><h1 id="启动你的网卡"><a href="#启动你的网卡" class="headerlink" title="启动你的网卡"></a>启动你的网卡</h1><p>1.登录root用户，编辑/etc/sysconfig/network-scripts/ifcfg-eth0 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#  vi /etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line"># BOOTPROTO=dhcp</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=eth0</span><br><span class="line">UUID=8ed6ad7b-9f3f-4b15-8b9a-5fc50f3efa00</span><br><span class="line">DEVICE=eth0</span><br><span class="line">ONBOOT=no</span><br></pre></td></tr></table></figure><p>2.将最后一项ONBOOT=no改为yes,退出vi编辑器,重启网络服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#  systemctl restart network</span><br></pre></td></tr></table></figure><p>3.使用yum grouplist来测试一下网络是否正常,若果设置正确，网卡已经在正常工作了</p><h1 id="配置固定的IP地址"><a href="#配置固定的IP地址" class="headerlink" title="配置固定的IP地址"></a>配置固定的IP地址</h1><p>如果此时centOS是安装在虚拟机中运行，非常建议配置成固定的IP地址，方便使用远程工具连接，只要要将配置改为如下即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static  (将# BOOTPROTO=dhcp改为static，即动态ip改为固定ip)</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=eth0</span><br><span class="line">UUID=8ed6ad7b-9f3f-4b15-8b9a-5fc50f3efa00</span><br><span class="line">DEVICE=eth0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">//添加如下配置</span><br><span class="line">IPADDR=192.168.31.162  # 内网ip地址</span><br><span class="line">GATEWAY=192.168.31.1   # 内网网关</span><br><span class="line">NETMASK=255.255.255.0  # 子网掩码</span><br></pre></td></tr></table></figure><p>接下来就能愉快地使用远程工具了，并开始使用centOS了</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>base shell 语法笔记</title>
      <link href="/2018/08/03/base-shell-%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/08/03/base-shell-%E8%AF%AD%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h2><p>“#”命令代表单行注释，在任何一行代码前加上”#”及将这行变为注释</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 我是注释</span><br></pre></td></tr></table></figure><h2 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h2><p>多行注释则使用:&lt;&lt;EOF  EOF来包裹注释区域<br>多行注释的格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">.....</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>变量定义不用加任何符号，直接用[变量名]=[变量值]：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;jianjian&quot;</span><br></pre></td></tr></table></figure><h2 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h2><ul><li>变量名和变量值与等号之间不能加空格</li><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>使用一个定义过的变量，只要在变量前加上美元符即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;jianjian&quot;</span><br><span class="line">echo $name</span><br><span class="line">echo $&#123;name&#125;</span><br></pre></td></tr></table></figure><p>花括号是可选的，主要是为了识别变量边界，例如这种情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ScriptName=&quot;Java&quot;</span><br><span class="line">echo &quot;i use $&#123;ScriptName&#125;Script&quot;</span><br></pre></td></tr></table></figure><p>不加上花括号则可能识别变量名为$ScriptNameScript</p><h2 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h2><p>给变量加上readonly命令就能把它变成一个只读的变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;jianjian&quot;</span><br><span class="line">readonly name</span><br></pre></td></tr></table></figure><h2 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h2><p>给变量加上unset命令就能删除这个变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;jianjian&quot;</span><br><span class="line">unset name</span><br><span class="line"># 将不会有任何输出</span><br><span class="line">echo $name</span><br></pre></td></tr></table></figure><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>在shell中存在三种变量</p><ul><li>局部变量:::局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li>环境变量:::所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li>shell变量:::shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="字符串定义"><a href="#字符串定义" class="headerlink" title="字符串定义"></a>字符串定义</h2><p>bash中的字符串可以用单引号和双引号，其区别就是，单引号内不能解释变量，而双引号内可以解释变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;jianjian&quot;</span><br><span class="line">echo &apos;$name&apos;</span><br><span class="line">echo &quot;$name&quot;</span><br></pre></td></tr></table></figure><p>上述代码将输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$name</span><br><span class="line">jianjian</span><br></pre></td></tr></table></figure><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firstName=&quot;im&quot;</span><br><span class="line">lastName=&quot;jianjian&quot;</span><br><span class="line">name=&quot;$&#123;firstName&#125;$&#123;lastName&#125;&quot;</span><br><span class="line">echo $name</span><br></pre></td></tr></table></figure><h2 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;imjianjian&quot;</span><br><span class="line">echo $&#123;#name&#125;</span><br></pre></td></tr></table></figure><h2 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str=&quot;oh! Bash is so good!&quot;</span><br><span class="line">echo `expr index &quot;$str&quot; is`</span><br><span class="line"># 将输出7，即在第七位找到is中的s</span><br></pre></td></tr></table></figure><p>他找到的是is中的任意一个字符，那个线出现就返回哪个<br>主义这里使用的是``而不是’’,这个符号在exc下面</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><h2 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h2><p>bash支支持一维数组，不支持多维数组<br>数组的下边从0开始，获取数组时下边可以使用算术表达式<br>数组用（）包裹，每个子元素都用空格分开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#直接定义</span><br><span class="line">arr1=(1 2 3 4)</span><br><span class="line">#单独定义</span><br><span class="line">arr2[0]=1</span><br><span class="line">arr2[1]=2</span><br><span class="line">arr2[2]=3</span><br><span class="line">arr2[3]=4</span><br></pre></td></tr></table></figure><h2 id="数组使用"><a href="#数组使用" class="headerlink" title="数组使用"></a>数组使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr=(1 2 3 4)</span><br><span class="line">echo $&#123;arr[0]&#125;</span><br></pre></td></tr></table></figure><h2 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h2><p>获取数组的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr=(1 2 3 4)</span><br><span class="line">echo $&#123;#arr(*)&#125;</span><br></pre></td></tr></table></figure><p>获取单个元素长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr=(12 22 32 42)</span><br><span class="line">echo $&#123;#arr[0]&#125;</span><br></pre></td></tr></table></figure><h1 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>我们在使用脚本文件的时候可以向文件中传递一些参数，脚本则可以使用$n这种方式来获取参数，$0代表文件名，$1代表的是第一个参数，$2代表第二个参数，以此类推。。。</p><p>test1.sh:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo &quot;文件名：$0&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line">echo &quot;第二个参数为：$2&quot;;</span><br></pre></td></tr></table></figure><p>然后用下列代码运行该文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash test1.sh 1 2</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件名：test1.sh</span><br><span class="line">第一个参数为：1</span><br><span class="line">第二个参数为：2</span><br></pre></td></tr></table></figure><h2 id="其他字符"><a href="#其他字符" class="headerlink" title="其他字符"></a>其他字符</h2><table><thead><tr><th>参数处理</th><th>说明</th></tr></thead><tbody><tr><td>$#</td><td>参数个数</td></tr><tr><td>$*</td><td>输出所有的参数</td></tr><tr><td>$$</td><td>当前脚本进程ID</td></tr><tr><td>$!</td><td>后台运行的最后一个进程ID</td></tr><tr><td>$@</td><td>与$*相同，但使用时家加引号</td></tr><tr><td>$-</td><td>现时shell当前选项</td></tr><tr><td>$?</td><td>现时最后命令的退出状态。0表示没有错误，其他表示错误</td></tr></tbody></table><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>bash本身不支持简单的数学计算，需要通过其他命令来实现，例如awk和expr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num=`expr 2 + 2`</span><br><span class="line">echo &quot;和为:$&#123;num&#125;&quot;</span><br></pre></td></tr></table></figure><p>其他运算符：<br>设a为10。b为20</p><table><thead><tr><th>运算符</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>+</td><td>加法</td><td><code>expr $a + $b</code> 结果为 30。</td></tr><tr><td>-</td><td>减法</td><td><code>expr $a - $b</code> 结果为 -10。</td></tr><tr><td>*</td><td>乘法</td><td><code>expr $a \* $b</code> 结果为  200。</td></tr><tr><td>/</td><td>除法</td><td><code>expr $b / $a</code> 结果为 2。</td></tr><tr><td>%</td><td>取余</td><td><code>expr $b % $a</code> 结果为 0。</td></tr><tr><td>=</td><td>赋值</td><td>a=$b 将把变量 b 的值赋给 a。</td></tr><tr><td>==</td><td>相等。用于比较两个数字，相同则返回 true。</td><td>[ $a == $b ] 返回 false。</td></tr><tr><td>!=</td><td>不相等。用于比较两个数字，不相同则返回 true。</td><td>[ $a != $b ] 返回 true。</td></tr></tbody></table><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符支支持数字，不支持字符串，除非字符串的值是数字</p><p>设a为10。b为20</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>-eq</td><td>检测两个数是否相等，相等返回 true。</td><td>[ $a -eq $b ] 返回 false。</td></tr><tr><td>-ne</td><td>检测两个数是否不相等，不相等返回 true。</td><td>[ $a -ne $b ] 返回 true。</td></tr><tr><td>-gt</td><td>检测左边的数是否大于右边的，如果是，则返回 true。</td><td>[ $a -gt $b ] 返回 false。</td></tr><tr><td>-lt</td><td>检测左边的数是否小于右边的，如果是，则返回 true。</td><td>[ $a -lt $b ] 返回 true。</td></tr><tr><td>-ge</td><td>检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td>[ $a -ge $b ] 返回 false。</td></tr><tr><td>-le</td><td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td>[ $a -le $b ] 返回 true。</td></tr></tbody></table><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>设a为10。b为20</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>!</td><td>非运算，表达式为 true 则返回 false，否则返回 true。</td><td>[ ! false ] 返回 true。</td></tr><tr><td>-o</td><td>或运算，有一个表达式为 true 则返回 true。</td><td>[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td></tr><tr><td>-a</td><td>与运算，两个表达式都为 true 才返回 true。</td><td>[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td></tr></tbody></table><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>设a为10。b为20</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>逻辑的 AND</td><td>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td></tr><tr><td>&#124;&#124;</td><td>逻辑的 OR</td><td>[[ $a -lt 100 &#124; &#124;  $b -gt 100 ]] 返回 true</td></tr></tbody></table><h2 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h2><p>设a 为 “abc”，b 为 “efg”：</p><table><thead><tr><th>运算符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>=</td><td>检测两个字符串是否相等，相等返回 true。</td><td>[ $a = $b ] 返回 false。</td></tr><tr><td>!=</td><td>检测两个字符串是否相等，不相等返回 true。</td><td>[ $a != $b ] 返回 true。</td></tr><tr><td>-z</td><td>检测字符串长度是否为0，为0返回 true。</td><td>[ -z $a ] 返回 false。</td></tr><tr><td>-n</td><td>检测字符串长度是否为0，不为0返回 true。</td><td>[ -n “$a” ] 返回 true。</td></tr><tr><td>str</td><td>检测字符串是否为空，不为空返回 true。</td><td>[ $a ] 返回 true。</td></tr></tbody></table><h2 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h2><table><thead><tr><th>操作符</th><th>说明</th><th>举例</th></tr></thead><tbody><tr><td>-b file</td><td>检测文件是否是块设备文件，如果是，则返回 true。</td><td>[ -b $file ] 返回 false。</td></tr><tr><td>-c file</td><td>检测文件是否是字符设备文件，如果是，则返回 true。</td><td>[ -c $file ] 返回 false。</td></tr><tr><td>-d file</td><td>检测文件是否是目录，如果是，则返回 true。</td><td>[ -d $file ] 返回 false。</td></tr><tr><td>-f file</td><td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td>[ -f $file ] 返回 true。</td></tr><tr><td>-g file</td><td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td>[ -g $file ] 返回 false。</td></tr><tr><td>-k file</td><td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td>[ -k $file ] 返回 false。</td></tr><tr><td>-p file</td><td>检测文件是否是有名管道，如果是，则返回 true。</td><td>[ -p $file ] 返回 false。</td></tr><tr><td>-u file</td><td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td>[ -u $file ] 返回 false。</td></tr><tr><td>-r file</td><td>检测文件是否可读，如果是，则返回 true。</td><td>[ -r $file ] 返回 true。</td></tr><tr><td>-w file</td><td>检测文件是否可写，如果是，则返回 true。</td><td>[ -w $file ] 返回 true。</td></tr><tr><td>-x file</td><td>检测文件是否可执行，如果是，则返回 true。</td><td>[ -x $file ] 返回 true。</td></tr><tr><td>-s file</td><td>检测文件是否为空（文件大小是否大于0），不为空返回 true。</td><td>[ -s $file ] 返回 true。</td></tr><tr><td>-e file</td><td>检测文件（包括目录）是否存在，如果是，则返回 true。</td><td>[ -e $file ] 返回 true</td></tr></tbody></table><h1 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h1><h2 id="输出普通字符串"><a href="#输出普通字符串" class="headerlink" title="输出普通字符串"></a>输出普通字符串</h2><p>echo 用于输出字符串，单双引号的作用不同，双引号中可以输出变量，并且双引号也可以省去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name=&quot;imjianjian&quot;</span><br><span class="line">echo &apos;my name is $name&apos;</span><br><span class="line">echo &quot;my name is $name&quot;</span><br><span class="line">echo my name is $name</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my name is $name</span><br><span class="line">my name is imjianjian</span><br><span class="line">my name is imjianjian</span><br></pre></td></tr></table></figure><h2 id="输出转义字符"><a href="#输出转义字符" class="headerlink" title="输出转义字符"></a>输出转义字符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;\&quot;hello world\&quot;&quot;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello world&quot;</span><br></pre></td></tr></table></figure><h2 id="换行-不换行"><a href="#换行-不换行" class="headerlink" title="换行/不换行"></a>换行/不换行</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># -e 开启转义</span><br><span class="line">:&lt;&lt;EOF</span><br><span class="line">\n 换行</span><br><span class="line">\c 不换行</span><br><span class="line">EOF</span><br><span class="line">echo -e &quot;hello world! \n&quot; </span><br><span class="line">echo -e &quot;hello world! \c&quot;</span><br></pre></td></tr></table></figure><h2 id="输出定向到文件"><a href="#输出定向到文件" class="headerlink" title="输出定向到文件"></a>输出定向到文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello world&quot; &gt; testFile</span><br></pre></td></tr></table></figure><h1 id="printf命令"><a href="#printf命令" class="headerlink" title="printf命令"></a>printf命令</h1><p>和echo相比，printf模仿了c语言中的printf()方法，所以移植性更好。printf支持用格式化字符串，定制字符床宽度，对齐等。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf string [argument]</span><br></pre></td></tr></table></figure><ul><li>string 为字符串</li><li>argument 为参数列表</li></ul><h2 id="格式替代符"><a href="#格式替代符" class="headerlink" title="格式替代符"></a>格式替代符</h2><p>在字符串中使用格式替换符占位，然后通过参数来对应带入，并最终输出对应字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf &quot;%-10s %-8s %-6s\n&quot; 姓名 性别 身高</span><br></pre></td></tr></table></figure><p>格式替换符有%s,%d,%c,%f等<br>%s是替代字符串，-为左对齐，不写则是右对齐。10表示字符串将会在10个字符以内的宽度上显示，不足则会用空格占满，炒出的也会正常显示</p><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><table><thead><tr><th>序列</th><th>说明</th></tr></thead><tbody><tr><td>\a</td><td>警告字符，通常为ASCII的BEL字符</td></tr><tr><td>\b</td><td>后退</td></tr><tr><td>\c</td><td>抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td>\f</td><td>换页（formfeed）</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车（Carriage return）</td></tr><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\</td><td>一个字面上的反斜杠字符</td></tr><tr><td>\ddd</td><td>表示1到3位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td>\0ddd</td><td>表示1到3位的八进制值字符</td></tr></tbody></table><h1 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h1><p>test命令用于检测某个条件是否成立，可以用来进行数值比较，字符比较，文件等测试。成立则返回true，否则返回false</p><h2 id="数值测试"><a href="#数值测试" class="headerlink" title="数值测试"></a>数值测试</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-eq</td><td>等于则为真</td></tr><tr><td>-ne</td><td>不等于则为真</td></tr><tr><td>-gt</td><td>大于则为真</td></tr><tr><td>-ge</td><td>大于等于则为真</td></tr><tr><td>-lt</td><td>小于则为真</td></tr><tr><td>-le</td><td>小于等于则为真</td></tr></tbody></table><h2 id="字符测试"><a href="#字符测试" class="headerlink" title="字符测试"></a>字符测试</h2><p>|参数|    说明|<br>|=    |等于则为真|<br>|!=    |不相等则为真|<br>|-z 字符串|    |字符串的长度为零则为真|<br>|-n 字符串|    |字符串的长度不为零则为真|</p><h2 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h2><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-e 文件名</td><td>如果文件存在则为真</td></tr><tr><td>-r 文件名</td><td>如果文件存在且可读则为真</td></tr><tr><td>-w 文件名</td><td>如果文件存在且可写则为真</td></tr><tr><td>-x 文件名</td><td>如果文件存在且可执行则为真</td></tr><tr><td>-s 文件名</td><td>如果文件存在且至少有一个字符则为真</td></tr><tr><td>-d 文件名</td><td>如果文件存在且为目录则为真</td></tr><tr><td>-f 文件名</td><td>如果文件存在且为普通文件则为真</td></tr><tr><td>-c 文件名</td><td>如果文件存在且为字符型特殊文件则为真</td></tr><tr><td>-b 文件名</td><td>如果文件存在且为块特殊文件则为真</td></tr></tbody></table><h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    ...command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    ...command</span><br><span class="line">else</span><br><span class="line">    ...command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a>if else-if else</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    ...command</span><br><span class="line">elif condition</span><br><span class="line">then </span><br><span class="line">    ...command</span><br><span class="line">else</span><br><span class="line">    ...command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    ...command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="until"><a href="#until" class="headerlink" title="until"></a>until</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="case"><a href="#case" class="headerlink" title="case"></a>case</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>和大部分语言一样，可以支持使用<strong>break</strong>和<strong>contiune</strong>,来跳出循环</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[function] functionName[()]</span><br><span class="line">&#123;</span><br><span class="line">    ....</span><br><span class="line">    return ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h2><p>与文件传参类似，函数也是使用相同的语法来传参，取参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test()&#123;</span><br><span class="line">    echo 第一个参数为$1</span><br><span class="line">    echo 第二个参数为$2</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    echo 第10个参数为$&#123;10&#125;</span><br><span class="line">    echo 参数共有$#个</span><br><span class="line">    echo 输出所有参数 $* </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当参数大于10时，参数需要用${n}来获取</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sun()&#123;</span><br><span class="line">    return `expr $1 + $2`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#调用</span><br><span class="line">sun 1 2</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure><p>点用函数后，结果通过<strong>$?</strong>来获得</p><h1 id="输入输出重定向"><a href="#输入输出重定向" class="headerlink" title="输入输出重定向"></a>输入输出重定向</h1><p>bash一般会将输入和所产生的输出都发送到终端，如果要将其输出到其他位置，则需要重定向</p><h2 id="重定向命令"><a href="#重定向命令" class="headerlink" title="重定向命令"></a>重定向命令</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>command &gt; file</td><td>将输出重定向到 file。</td></tr><tr><td>command &lt; file</td><td>将输入重定向到 file。</td></tr><tr><td>command &gt;&gt; file</td><td>将输出以追加的方式重定向到 file。</td></tr><tr><td>n &gt; file</td><td>将文件描述符为 n 的文件重定向到 file。</td></tr><tr><td>n &gt;&gt; file</td><td>将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr><tr><td>n &gt;&amp; m</td><td>将输出文件 m 和 n 合并。</td></tr><tr><td>n &lt;&amp; m</td><td>将输入文件 m 和 n 合并。</td></tr><tr><td>&lt;&lt; tag</td><td>将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr></tbody></table><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &gt; file1</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将历史命令输出到history.txt文件中</span><br><span class="line">history &gt; history.txt</span><br></pre></td></tr></table></figure><h2 id="输出重定向-1"><a href="#输出重定向-1" class="headerlink" title="输出重定向"></a>输出重定向</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; file1</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 统计users文件的行数</span><br><span class="line">wc -l &lt; users</span><br></pre></td></tr></table></figure><h2 id="dev-null"><a href="#dev-null" class="headerlink" title="/dev/null"></a>/dev/null</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 所有被重定向到/dev/null的文件都会被丢弃，可以起到禁止任何输出的作用。</span><br><span class="line"># 可以理解为自动清理的垃圾桶</span><br><span class="line">command &gt; /dev/null</span><br></pre></td></tr></table></figure><h1 id="文件引用"><a href="#文件引用" class="headerlink" title="文件引用"></a>文件引用</h1><p>和其它语言一样，bash也可以引用外部文件。这样可以把一些公共代码封装到一个独立的文件中。</p><h2 id="引用方式"><a href="#引用方式" class="headerlink" title="引用方式"></a>引用方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#.和文件名中要有一个空格</span><br><span class="line">. filename </span><br><span class="line">或</span><br><span class="line">source filename</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> bash </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue组件传值</title>
      <link href="/2018/07/13/vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/"/>
      <url>/2018/07/13/vue%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="父组件向子组件传值"><a href="#父组件向子组件传值" class="headerlink" title="父组件向子组件传值"></a>父组件向子组件传值</h1><p>父组件向子组件传值的方式通常是通过子组件定义的props来完成的。子组件定义props作为传入的数据，父组件应用子组件时绑定props，就能够动态地改变props的值，实现实时传值。</p><blockquote><p>Son.vue</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;Son&apos;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: String   //定义了props及其类型</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>Father.vue</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;Son :msg=&quot;myMsg&quot;&gt;&lt;/Son&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;myMsg&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &apos;./Son.vue&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      myMsg: &apos;Welcome to Your Vue.js App&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>Son组件定义了props（msg）且类型为String，Father组件引用了Son组件，并传入Mymsg作为props值。Father组件还用Input组件绑定了myMsg，这样在Input中输入时，Son组件也会发生更新。</p><h1 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h1><p>子组件向父组件传值一般通过$emit事件，出发$emit事件，会将参数一同传到监听器的回调。一般有子组件出发$emit事件并传值，由父组件监听。一个$emit事件对应使用一个时间名。</p><blockquote><p>Son.vue</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;msg&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;button @click=&apos;sendtoFather&apos;&gt;clear&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;Son&apos;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    msg: String</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sendtoFather: function () &#123;</span><br><span class="line">      this.$emit(&apos;clear&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>在子组件代码中加入向父组件发送消息的事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button @click=&apos;sendtoFather&apos;&gt;clear&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>该事件见用于清空父组件的myMsg值</p><p>父组件也对应添加了事件监听，<strong>@clear=’clear’</strong>。</p><blockquote><p>Father.vue</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;Son :msg=&quot;myMsg&quot; @clear=&apos;clear&apos;&gt;&lt;/Son&gt;</span><br><span class="line">      &lt;input type=&quot;text&quot; v-model=&quot;myMsg&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Son from &apos;./Son.vue&apos;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    Son</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      myMsg: &apos;Welcome to Your Vue.js App&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    clear: function () &#123;</span><br><span class="line">      this.myMsg = &apos;&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="兄弟组件传值"><a href="#兄弟组件传值" class="headerlink" title="兄弟组件传值"></a>兄弟组件传值</h1><p>兄弟组件传值可以通过共同的父组件作为桥梁来实现，子组件A通过$emit事件将值传到父组件，父组件再通过Props来把值传给子组件B，具体的实现过程参照前面的方法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flexbox 快速上手</title>
      <link href="/2018/07/11/flexbox-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2018/07/11/flexbox-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p>flexbox是一个用于灵活布局的盒子模型，即使在不知道容器大小或者元素也未知的情况下都可以只能地调节占用空间。即元素的大小时弹性的，是自动计算的。</p><h1 id="容器与子元素"><a href="#容器与子元素" class="headerlink" title="容器与子元素"></a>容器与子元素</h1><blockquote><p>属性：</p><ul><li>display:flex</li><li>display:inline-flex</li></ul></blockquote><p>要使用flexbox布局，必须将容器的display属性设置为flex|inline-flex。</p><p>现为完成一个最简单的flex布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;flexbox&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>这里省去其他样式代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.flexbox&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原本应该数列排放的div在flexbox的作用下变成了横排,这是怎么回事呢？往下看就知道了。</p><p><img src="/img/flexbox/flex1.png" alt=""></p><h1 id="设置容器"><a href="#设置容器" class="headerlink" title="设置容器"></a>设置容器</h1><blockquote><p>属性：</p><ul><li>flex-direction ：主轴方向</li><li>flex-wrap ：是否换行     </li><li>flex-flow : flex-direction和flex-wrap 的快捷属性</li><li>justify-content ：主轴的对其方向</li><li>align-items </li><li>align-content</li></ul></blockquote><h2 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h2><p>在flexbox中将布局分为主轴和侧轴方向，即水平和竖直的两条垂直交叉的轴。</p><p>主轴的方向由<strong>flex-direction</strong>控制，其值有row|column|row-reverse|column-reverse。即按照行方向或列方向。默认值为row，这也就解释了为什么之前的几个div会横向摆放了。</p><p>如果我们将上面的代码改成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flexbox&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction:column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，我们将得到数列摆放的几个div</p><p><img src="/img/flexbox/flex2.png" alt=""></p><h2 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h2><p>我们依旧按照主轴方向为row，继续增加20个div会怎么样？</p><p><img src="/img/flexbox/flex3.png" alt=""></p><p>那样将会压缩子元素自身大小并且不会换行，因为<strong>flex-row</strong>默认值为<strong>nowrap</strong>,现在我们将其设置为<strong>wrap</strong>，他将会自动换行，并且保持主轴方向和子元素的大小。</p><p><img src="/img/flexbox/flex4.png" alt=""></p><h2 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h2><blockquote><p>flex-flow是flex-direction和flex-wrap的合并的快捷属性，我们可以先这么写：flex-flow：row wrap;</p></blockquote><h2 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h2><p>通常我们要通过text-align，margin，float来完成内容如何对其，在flexbox中提供了一个更简单的防暑让我们可以快速完成内容对其，即<strong>justify-content</strong>属性，它的值有<strong>flex-start | flex-end | center | space-between | space-around</strong></p><ul><li>flex-start ：向主轴起始位置对齐</li><li>flex-end ：向主轴末位置对齐</li><li>center ：向中对齐</li><li>space-between ：两端靠边，中间空间均分</li><li>space-around ：两端与中间都均分空间</li></ul><p>下图是设置为flex-end的效果，其他属性就不展示了，自己动手吧0.0</p><p><img src="/img/flexbox/flex5.png" alt="flex-end"></p><h2 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h2><p>align-item属性和justify-content属性类似。不过他是用于设置侧轴方向上的对齐方式的。它的值有<strong>flex-start | flex-end | center | stretch | baseline</strong>。其默认值为<strong>stretch</strong>，即与容器高度一致。</p><ul><li>flex-start ：对齐侧轴起始位置</li><li>flex-end  ：对齐侧轴末位置</li><li>center ：侧轴居中对齐</li><li>stretch ：填充侧轴</li><li>baseline ：沿着各自的基线对齐</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.flexbox&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: flex-end;</span><br><span class="line">    height:200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/flexbox/flex6.png" alt="flex-end"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.flexbox&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    align-items: baseline;</span><br><span class="line">    height:200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/flexbox/flex7.png" alt="baseline"></p><h2 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h2><p>align-content是用于设置多行对齐的，align-content属性参照align-item，除了没有baseline，其余是一样的，默认值也是stretch。</p><h1 id="设置子元素"><a href="#设置子元素" class="headerlink" title="设置子元素"></a>设置子元素</h1><blockquote><p>属性：<br>order ： 重新排列子元素<br>flex-grow ：子元素缩放<br>flex-shrink ：子元素缩放<br>flex-basis ：初始大小<br>align-self ：单一元素的侧轴对齐方式</p></blockquote><h2 id="order"><a href="#order" class="headerlink" title="order"></a>order</h2><p>flexbox允许在容器设置好子元素的排列方式之后，在对子元素的位置进行调整。<strong>order</strong>就是用于单个元素重排的。</p><p>所有子元素order属性默认为0。当我们子元素设置其他值的时候，将会以order值的大小对子元素进行重新排序，按照从小到大的顺序。</p><p>默认形况下：<br><img src="/img/flexbox/flex8.png" alt="order"></p><p>将2的div值设置为1：<br><img src="/img/flexbox/flex9.png" alt="order"></p><p>将2的div值设置为2，3的order设置为1：<br><img src="/img/flexbox/flex10.png" alt="order"></p><h2 id="flex-grow和flex-shrink"><a href="#flex-grow和flex-shrink" class="headerlink" title="flex-grow和flex-shrink"></a>flex-grow和flex-shrink</h2><p>flex-frowhe flex-shrink用于设置当子元素没有占满容器时，如何对其进行缩放。</p><p>默认情况下：<br><img src="/img/flexbox/flex11.png" alt="flex-grow"></p><p>flex-grow设置为1：<br><img src="/img/flexbox/flex12.png" alt="flex-grow"></p><h2 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h2><p>设置子元素初始大小。</p><h2 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h2><p>改变单一元素的侧轴对其方式，属性和align-items相同。</p><h1 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h1><p><strong>flex</strong>属性是flex-grow，flex-shrink和flex-basic属性的缩写。</p><blockquote><p>flex:1 1 10px;等同于flex-grow:1;flex-shrink:0;flex-basic:10px;</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grid Layout 快速上手</title>
      <link href="/2018/07/09/Grid-Layout-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2018/07/09/Grid-Layout-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p>CSS3 Grid Layout是一个新的模块，主要适用于进行二维的表格布局，用来优化用户界面设计，使用网格容器将子元素灵活地插入到布局中去。</p><h1 id="容器与子元素"><a href="#容器与子元素" class="headerlink" title="容器与子元素"></a>容器与子元素</h1><blockquote><p>属性: </p><ul><li>diaplay:grid; 设置容器</li><li>grid-gap:网格间距</li></ul></blockquote><p>Grid布局的核心要素就是容器和子元素了，容器实际上就是网格，而子元素就是其中的每一个小格子。</p><p>先写一个最简单的网格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;gridbox&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item item1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item7&quot;&gt;7&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.gridbox&#123;</span><br><span class="line">    display: grid; </span><br><span class="line">    grid-gap:1px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用grid布局必须把容器的display属性设置为grid。没有定义子元素该在网格中如何放置，默认每个子元素独占一行。</p><p><img src="/img/gridlayout/grid1.png" alt=""></p><h1 id="行与列"><a href="#行与列" class="headerlink" title="行与列"></a>行与列</h1><blockquote><p>属性: </p><ul><li>grid-template-columns:网格列宽度</li><li>grid-template-rows:网格行的高度</li></ul></blockquote><p>Grid 布局中使用<strong>grid-template-columns</strong>和<strong>grid-template-rows</strong>来设置行与列的大小。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;gridbox&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item item1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>设置值的数量和大小分别代表网页行列的数量和格子的宽高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.gridbox&#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-gap: 1px;</span><br><span class="line">    grid-template-columns:100px 100px 100px;</span><br><span class="line">    grid-template-rows:100px 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/gridlayout/grid2.png" alt=""></p><p>网格布局中还可以使用一个新的单位<strong>fr</strong>，它用于计算并分配剩余的空间。现在将上面的单位改成fr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.gridbox&#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-gap: 1px;</span><br><span class="line">    grid-template-columns:1fr 1fr 1fr;</span><br><span class="line">    grid-template-rows:1fr 1fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>横向纵向都按照比例分配，横向会占满所有未分配的空间，而纵向则是恰好包裹内容。</p><p><img src="/img/gridlayout/grid3.png" alt=""></p><p>固定的大小和fr结合使用会怎么样呢?</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.gridbox&#123;</span><br><span class="line">    display: grid;</span><br><span class="line">    grid-gap: 1px;</span><br><span class="line">    grid-template-columns:100px 1fr 1fr;</span><br><span class="line">    grid-template-rows:100px 1fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个格子是固定大小的，其他格子依旧按照剩余空间分配。</p><p><img src="/img/gridlayout/grid4.png" alt=""></p><blockquote><p><strong>grid-template-columns:1fr 1fr 1fr;</strong>可以使用简洁写法<strong>grid-template-columns:repeat(3,1fr);</strong></p></blockquote><h1 id="跨行与跨列"><a href="#跨行与跨列" class="headerlink" title="跨行与跨列"></a>跨行与跨列</h1><blockquote><p>属性：</p><ul><li>grid-column-start ：跨列起始网格线</li><li>grid-column-end   ：跨列终点网格线</li><li>grid-row-start    ：跨行起始网格线</li><li>grid-row-end      ：跨行终点网格线</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;gridbox&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item item1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>在容器中定义好每行和每列的大小。然后再子元素中使用<strong>grid-column-start</strong>和<strong>grid-column-end</strong>来确定该元素跨越的网格的起始和终点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.gridbox&#123;</span><br><span class="line">            display: grid; </span><br><span class="line">            grid-gap: 1px;</span><br><span class="line">            grid-template-columns:100px 100px 100px;</span><br><span class="line">            grid-template-rows:100px 100px 100px;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         .item1&#123;</span><br><span class="line">            grid-column-start:1;</span><br><span class="line">            grid-column-end:3;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        .item3&#123;</span><br><span class="line">            grid-row-start:2;</span><br><span class="line">            grid-row-end:4;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        .item6&#123;</span><br><span class="line">            grid-column-start:2;</span><br><span class="line">            grid-column-end:4;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="/img/gridlayout/grid5.png" alt=""></p><blockquote><p><strong>grid-column-start:2;grid-column-end:4;</strong>可以简写为grid-column: 2 / 4;<br>同理，<strong>grid-row-start:2;grid-row-end:4;</strong>可以简写为grid-row: 2 / 4;</p></blockquote><h1 id="自动对齐"><a href="#自动对齐" class="headerlink" title="自动对齐"></a>自动对齐</h1><blockquote><p>属性:</p><ul><li>grid-auto-flow:自动对齐(row/column)</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;gridbox&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item item1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item7&quot;&gt;7&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>当<strong>grid-auto-flow</strong>设置为column时,子元素会自动向列对齐,网格子元素会依次竖向摆放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.gridbox&#123;</span><br><span class="line">    display: grid; </span><br><span class="line">    grid-gap: 1px;</span><br><span class="line">    grid-auto-flow: column;</span><br><span class="line">    grid-template-rows: 50px 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/gridlayout/grid6.png" alt=""></p><p>同样的,当<strong>grid-auto-flow</strong>设置为row时,子元素会自动向行对齐,网格子元素会依次横向摆放。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.gridbox&#123;</span><br><span class="line">    display: grid; </span><br><span class="line">    grid-gap: 1px;</span><br><span class="line">    grid-auto-flow: row;</span><br><span class="line">    grid-template-columns: 100px 100px 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/gridlayout/grid7.png" alt=""></p><h1 id="grid与grid-area"><a href="#grid与grid-area" class="headerlink" title="grid与grid-area"></a><strong>grid</strong>与<strong>grid-area</strong></h1><blockquote><p>属性:</p><ul><li>grid:用于将grid-template-column和grid-template-row结合并且用更直观的方式展示</li><li>grid-area:用于为每一块子元素命名</li></ul></blockquote><p>CSS grid 布局中还有一个用于容器的超级属性<strong>grid</strong>,以及另一个用于子元素的属性<strong>grid-area</strong>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;gridbox&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;item item1&quot;&gt;1&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item2&quot;&gt;2&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item3&quot;&gt;3&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item4&quot;&gt;4&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item5&quot;&gt;5&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item6&quot;&gt;6&lt;/div&gt;</span><br><span class="line">    &lt;div class=&quot;item item7&quot;&gt;7&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>grid属性分为两个部分用”/“隔开,前一部分设置网格行的分布和高度,<strong>“one one one” 200px</strong>及这一行由one独占三个网格,并且改行高度为200px.而后一部分则设置网格列的宽度.<strong>1fr 1fr 1fr</strong>表示网格列宽比例相等.</p><p>grid-area设置了每一个子元素的命名,在grid属性中中使用到的命名都必须由该属性定义.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.gridbox&#123;</span><br><span class="line">    display: grid; </span><br><span class="line">    grid-gap: 1px;</span><br><span class="line">   grid:&quot;one one one&quot; 150px</span><br><span class="line">         &quot;two three four&quot; 100px</span><br><span class="line">         &quot;five six seven&quot; 50px</span><br><span class="line">         / 1fr 1fr 1fr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item1&#123;</span><br><span class="line">    grid-area: one;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item2&#123;</span><br><span class="line">    grid-area: two;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item3&#123;</span><br><span class="line">    grid-area: three;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item4&#123;</span><br><span class="line">    grid-area: four;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item5&#123;</span><br><span class="line">    grid-area: five;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item6&#123;</span><br><span class="line">    grid-area: six;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.item7&#123;</span><br><span class="line">    grid-area: seven;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img/gridlayout/grid8.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型和原型链</title>
      <link href="/2018/02/26/JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2018/02/26/JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>javascript不包含传统的类继承模型，而是使用 prototype 原型模型。<br>虽然这经常被当作是 JavaScript 的缺点被提及，其实基于原型的继承模型比传统的类继承还要强大。实现传统的类继承模型是很简单，但是实现 JavaScript 中的原型继承则要困难的多。ES6新增加的class语法糖使得这种继承方式实现起来更加简单，但其原理还是原型继承，而不是类继承。<br>由于 JavaScript 是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的，今天我们就来了解一下原型和原型链。</p><h1 id="函数对象和普通对象"><a href="#函数对象和普通对象" class="headerlink" title="函数对象和普通对象"></a>函数对象和普通对象</h1><p>javascript中的对象分为函数对象和普通对象。其区分起来也很简单，<strong>所有Function的实例都是函数对象，其他的都是普通对象</strong>，Object和Function都是函数对象。</p><p>函数对象在javascript中起到模拟类的作用，我们可以使用<strong>new</strong>来创建一个函数对象的实例，这个实例是一个普通对象，它通过__proto__从函数对象的prototype中继承属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var Person = function()&#123;&#125;;</span><br><span class="line">Person.prototype.name = &apos;xiaoming&apos;;</span><br><span class="line">Person.prototype.age = 17;</span><br><span class="line"></span><br><span class="line">var p1 = new Person()</span><br><span class="line"></span><br><span class="line">p1.name; //&apos;xiaoming&apos;</span><br><span class="line">p1.age; //17</span><br><span class="line">p1.hasOwnProperty(&apos;name&apos;); //false,name属性是从原型处获得的</span><br><span class="line">p1.__proto__; //&#123;name: &quot;xiaoming&quot;, age: 17, constructor: ƒ&#125;</span><br><span class="line">p1.__proto__ == Person.prototype; //true</span><br></pre></td></tr></table></figure><h1 id="prototype和-proto"><a href="#prototype和-proto" class="headerlink" title="prototype和__proto__"></a>prototype和__proto__</h1><p>由上面的例子可以得知，原型继承是由prototype和__proto__两个属性来完成的，只要知道这两个属性分别指向哪儿，他们是如何工作的，那么就能弄明白原型继承了。</p><p>这里依旧使用上面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var Person = function()&#123;&#125;;</span><br><span class="line">Person.prototype.name = &apos;xiaoming&apos;;</span><br><span class="line">Person.prototype.age = 17;</span><br><span class="line"></span><br><span class="line">var p1 = new Person()</span><br><span class="line"></span><br><span class="line">p1.prototype;                       //undefined,普通对象没有prototype</span><br><span class="line">p1.__proto__ == Person.prototype; //true</span><br><span class="line"></span><br><span class="line">Person.prototype; //&#123;name: &quot;xiaoming&quot;, age: 17, constructor: ƒ&#125;</span><br><span class="line">Person.__proto__ == Function.prototype;         //true</span><br><span class="line">Person.prototype.__proto__ == Object.prototype; //true</span><br><span class="line"></span><br><span class="line">Function.__proto__ == Function.prototype;           //true</span><br><span class="line">Function.prototype.__proto__ == Object.prototype;   //true</span><br><span class="line"></span><br><span class="line">Object.__proto__ == Function.prototype; //true;</span><br><span class="line">Object.prototype.__proto__ == null;     //true</span><br></pre></td></tr></table></figure><p>由上述的例子可以得知：</p><blockquote><ul><li><strong>普通对象没有prototype属性，只有__proto__属性，而函数对象都有</strong></li><li><strong>普通对象的__proto__属性都指向其原型函数对象的prototype</strong></li><li><strong>函数对象的__proto__属性都指向Function.prototype,Object的__proto__属性也是</strong></li><li><strong>函数对象的prototype.__proto__属性都指向Object.prototype,除了Object.prototype.__proto__ –&gt; null</strong></li></ul></blockquote><p>我们通过new来创建函数对象的实例，而一个实例不是不能再实例化的，所以普通对象没有prototype就很好理解了。</p><p>而对于函数对象来说</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof Person.prototype //&quot;object&quot;</span><br><span class="line">Person.prototype.__proto__ == Object.prototype //true</span><br></pre></td></tr></table></figure><p>这里把原型对象prototype单独拿出来，它其实是一个object，它存放了函数对象需要被继承的属性，以及构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person.__proto__ =  Funtion.prototype</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name:&quot;xiaoming&quot;,</span><br><span class="line">    age:17,</span><br><span class="line"></span><br><span class="line">    constructor:Person,    </span><br><span class="line">    __proto__:object //Object.prototype</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有函数对象的__proto__属性都指向Function.prototype，包括Function自身的__proto__属性和Object的__proto__属性</p><p>作为所有对象的原型Object，普通对象的__proto__属性都指向Object.prototype。而Object.prototype.__proto__ = null,万物都是由无到有，原型链的末端就是null了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1.__proto__ == Person.prototype;            //true</span><br><span class="line">p1.__proto__.__proto__ == Object.prototype;  //true</span><br><span class="line">p1.__proto__.__proto__.__proto__ == null;    //true</span><br></pre></td></tr></table></figure><p>由此可以再得到一个结论</p><blockquote><p>__proto__和prototype在原型链中是自动分配的，__proto__用于连接对象和原型对象，prototype用于保存原型属性，构造函数和__proto__属性</p></blockquote><p>这里再引用一张图</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/27/161d355ad49d78e2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><center>图片来自：https://juejin.im/post/5a944f485188257a804aba6d#heading-5</center><p>通过这张图应该就能很清楚的看到对象之间的继承关系了。</p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var Person = function(name,age)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.getName = function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.getAge = function()&#123;</span><br><span class="line">    return this.age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var p1 = new Person(&apos;xiaoming&apos;,17);</span><br><span class="line">p1.name; //&apos;xiaoming&apos;;</span><br></pre></td></tr></table></figure><p>这里在Person上建立构造函数，在执行new操作时会执行这个构造函数。现在得到的p1是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name:&quot;xiaoming&quot;,</span><br><span class="line">    age:17,</span><br><span class="line">    __proto__:object  //Person.prototype</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在来试试多重继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var A = function()&#123;&#125;;</span><br><span class="line">A.prototype.a = 1;</span><br><span class="line">A.prototype.b = 2;</span><br><span class="line"></span><br><span class="line">var B = function()&#123;&#125;</span><br><span class="line">B.prototype.__proto__ = A.prototype;</span><br><span class="line">B.prototype.a = 3;</span><br><span class="line"></span><br><span class="line">var c = new B();</span><br><span class="line">c.a  //3</span><br><span class="line">c.b  //2</span><br></pre></td></tr></table></figure><p>这里我们让B继承于A,再实例化一个B。执行c.a时，c自身并没有这个属性，于是它顺着原型链去寻找a属性，首先是a.__proto__即B.prototype,B的原型对象上有这个属性，于是它便不再继续寻找，返回了3。执行c.b时同理，在B的原型对象上不存在b属性，于是继续顺着原型链寻找，在A的原型对象上找到了b属性，返回2。</p><h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>constructor永远指向函数本身，所以在上面的例子中可以使用函数本身作为构造函数，构造函数中属性会直接赋值在实例上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Person = function(name,age)&#123;</span><br><span class="line">    this.name = &apos;xiaoming&apos;;</span><br><span class="line">    this.age = 17</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 = new Person();</span><br></pre></td></tr></table></figure><p>此时p1对象结构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name:&apos;xiaoming&apos;,</span><br><span class="line">    age:17,</span><br><span class="line">    __proto__:object //Person.prototype</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor == Person //true</span><br><span class="line">Person.prototype.constructor.prototype.constructor == Person //true</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>对象通过__proto__来连接原型对象prototype，也通过__proto__来进行原型链上的属性查找，直到原型链的末端:Object.prototype.__proto__–&gt;null。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用一个hello world项目学习webpack</title>
      <link href="/2018/02/08/%E7%94%A8%E4%B8%80%E4%B8%AAhello%20world%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0webpack/"/>
      <url>/2018/02/08/%E7%94%A8%E4%B8%80%E4%B8%AAhello%20world%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0webpack/</url>
      
        <content type="html"><![CDATA[<h1 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h1><p><a href="https://github.com/imjianjian/webpack-in-hello-world" target="_blank" rel="noopener">项目地址</a></p><p>项目结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- src</span><br><span class="line">    - app</span><br><span class="line">        - App.vue</span><br><span class="line">    - img</span><br><span class="line">        - logo.png</span><br><span class="line">    - style</span><br><span class="line">        - app.scss</span><br><span class="line">    - index.html</span><br><span class="line">    - main.js</span><br></pre></td></tr></table></figure><h1 id="webpack基本概念"><a href="#webpack基本概念" class="headerlink" title="webpack基本概念"></a>webpack基本概念</h1><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>即webpack打包的入口js文件，可以根据项目实际情况配置成但入口或者多入口,webpack会根据入口文件内的引入的文件绘制依赖图，将该模块和模块对应的依赖都打包到一个文件中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//单入口</span><br><span class="line">const config = &#123;</span><br><span class="line">    entry:&apos;a.js&apos;</span><br><span class="line">&#125;</span><br><span class="line">//多入口</span><br><span class="line">const config = &#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        a:&apos;a.js&apos;,</span><br><span class="line">        b:[&apos;b1.js&apos;,&apos;b2.js&apos;]  //多个文件打包为一个文件</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>即webpack打包后的输出，即使此时的entry中存在多个入口，也只提供单一的输出配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//单一入口情况,一下将所有文件都打包到dist/bundle.js里</span><br><span class="line">const config = &#123;</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;bundle.js&apos;,</span><br><span class="line">        path:path.join(__dirname,&apos;dist&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//多入口情况</span><br><span class="line">const config =&#123;</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:&apos;[name].js&apos;,</span><br><span class="line">        path:path.join(__dirname,&apos;dist&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的输出文件名中可以使用[name],[hash],[chunkhash]等占位，这样输出的文件名中就有带有资源hash值。[hash]是本次打包所有资源的hash值，同义词打包的文件得到的hash是一样的，而[chunkhash]是单个文件打包的hash值，每个文件且每次打包都不相同。还可以使用[hash:8]来取hash值得位数</p><h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>webpack是一个js bundler，如果需要它对非js得模块，例如typeScript，sass，less，vue等模块进行打包，则需要对应的loader进行转换。而且同一种资源有时需要使用不止一种loader。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const config =&#123;</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.vue$/, </span><br><span class="line">                use: [&#123;loader: &apos;vue-loader&apos;&#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                test:/\.scss/,</span><br><span class="line">                use:[</span><br><span class="line">                    &#123;loader:&apos;style-loader&apos;&#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader:&apos;css-loader&apos;,</span><br><span class="line">                            options: &#123;</span><br><span class="line">                                modules: true</span><br><span class="line">                            &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;loader:&apos;sass-loader&apos;&#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在rules数组中的每一项都是一种模块类型的转换规则，test参数匹配对应后缀的文件，use数组中配置对应使用的loader以及配置loader的其他参数。</p><blockquote><p>官方推荐的<a href="https://doc.webpack-china.org/loaders/" target="_blank" rel="noopener">loader</a></p></blockquote><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>plugins用于解决其他loader无法做到的事情，比如压缩资源，启动开发服务器等等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);</span><br><span class="line">const path = require(&apos;path&apos;);</span><br><span class="line"></span><br><span class="line">const config =&#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            template:path.join(__dirname,&apos;src/index.html&apos;)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>plugins数组的每一项就是一个插件</p><blockquote><p>webpack自带的以及推荐使用的<a href="https://doc.webpack-china.org/plugins/" target="_blank" rel="noopener">Plugins</a></p></blockquote><h1 id="webpack配置文件结构"><a href="#webpack配置文件结构" class="headerlink" title="webpack配置文件结构"></a>webpack配置文件结构</h1><p>webpack默认的配置文件名为webpack.config.js，当然也可以自定义其他文件名，只要在webpack –config filename命令中修改filename为当前的配置文件即可。</p><blockquote><p>完整的webpack配置参数可以查看<a href="https://doc.webpack-china.org/configuration/#-" target="_blank" rel="noopener">官方文档</a></p></blockquote><h1 id="开发模式和打包模式-Dev-amp-Build"><a href="#开发模式和打包模式-Dev-amp-Build" class="headerlink" title="开发模式和打包模式(Dev&amp;Build)"></a>开发模式和打包模式(Dev&amp;Build)</h1><p>可以通过命令行向webpack闯入参数，以判断使用开发模式还是打包。</p><p>在package.json中配置npm script：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack --config webpack.config.js&quot;,</span><br><span class="line">  &quot;dev&quot;: &quot;cross-env NODE_ENV=develement webpack-dev-server --config webpack.config.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>命令行中使用了cross-env用于跨平台地设置及使用环境变量，具体的参照<a href="https://github.com/kentcdodds/cross-env" target="_blank" rel="noopener">官方github说明</a></p></blockquote><p>在build和dev中我们分别向webpack传入了不同的NODE_ENV参数值。在webpacl配置文件中，可以使用process.env.NODE_ENV来的到这个值，以便判断该运行那哪个模式。</p><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>在webpack中用devServer参数来配置它，在此之前我们需要先判断是否运行在开发模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var WebpackDevServer = require(&apos;webpack-dev-server&apos;);</span><br><span class="line"></span><br><span class="line">//获得NODE_ENV参数，用于判断处于开发模式还是打包模式</span><br><span class="line">var isDev = process.env.NODE_ENV === &apos;develement&apos;;</span><br><span class="line"></span><br><span class="line">const config = &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(isDev)&#123;</span><br><span class="line">    //webpack-dev-server不能使用chunkhash，否则会报错</span><br><span class="line">    config.output.filename =&apos;[name]-[hash].js&apos;;</span><br><span class="line">    config.devtool = &apos;#cheap-module-eval-source-map&apos;;</span><br><span class="line"></span><br><span class="line">    config.plugins.push(</span><br><span class="line">        new webpack.HotModuleReplacementPlugin(), //热更新插件</span><br><span class="line">        new webpack.NoEmitOnErrorsPlugin() //防止错误信息导致webpack退出</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    //启动开发服务器</span><br><span class="line">    config.devServer=&#123;</span><br><span class="line">        contentBase:path.join(__dirname,&apos;dist&apos;),</span><br><span class="line">        compress:true, //启用gzip压缩</span><br><span class="line">        port:8080,</span><br><span class="line">        hot:true, //启用webpack热模块替换特性</span><br><span class="line">        open:true //是否在开始服务器后打开浏览器</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在devServer中配置hot:true并不在代表已经启用了热模块替换，还需要使用webpack.HotModuleReplacementPlugin插件才能生效，hot仅仅是一个开关</p><h1 id="单独打包css文件"><a href="#单独打包css文件" class="headerlink" title="单独打包css文件"></a>单独打包css文件</h1><p>想vue文件中的样式通常会被打包进js文件中，在该组件被加载时同时加载样式。而有一些公共的样式通常会写在单独的文件中，如果我们在多个组件中引用公共样式，那么公共样式会在多个js模块中被打包，这样会增加文件的体积。这是应该将这些公共样式提取出来单独打包。</p><p>这里我们使用<strong>extract-text-webpack-plugin</strong>插件来提取公共样式，所以此时我们的配置文件中就该改为这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var ExtracTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);</span><br><span class="line"></span><br><span class="line">const config =&#123;</span><br><span class="line">    module:&#123;</span><br><span class="line">        rules:[</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.scss/,</span><br><span class="line">                use: ExtracTextPlugin.extract(&#123;</span><br><span class="line">                    use: [&#123;</span><br><span class="line">                        loader: &apos;css-loader&apos;</span><br><span class="line">                    &#125;, &#123;</span><br><span class="line">                        loader: &apos;sass-loader&apos;</span><br><span class="line">                    &#125;]</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">         new ExtracTextPlugin(&apos;style-[contentHash:8].css&apos;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就能将scss文件单独打包了</p><h1 id="提取公共模块"><a href="#提取公共模块" class="headerlink" title="提取公共模块"></a>提取公共模块</h1><p>同理我们在项目中使用类库，也需要单独打包，以防止重复加载，节省流量。</p><p>这里使用的是webpack自带的插件<strong>CommonsChunkPlugin</strong>，在entry中添加vendor模块，然后在插件中配置单独打包vue。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var config = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app:path.join(__dirname, &apos;src/main.js&apos;), </span><br><span class="line">        vendor:[&apos;vue&apos;]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">            name:&apos;vendor&apos;</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gulp4增量编译</title>
      <link href="/2018/01/31/gulp4%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/"/>
      <url>/2018/01/31/gulp4%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>在任何构建工具中增量编译都是一个必不可少的优化方式。即在编译过程中仅编译那些修改过的文件，可以减少许多不必要的资源消耗，也能减少编译时常。而且gulp是一个配置简单，学习性价比很高的工具。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>在gulp官方推荐了四个插件用于增量编译：</p><ul><li><a href="https://github.com/sindresorhus/gulp-changed" target="_blank" rel="noopener">gulp-changed</a> - only pass through changed files</li><li><a href="https://github.com/tschaub/gulp-newer" target="_blank" rel="noopener">gulp-newer</a> - pass through newer source files only, supports many:1 source:dest</li><li><a href="https://github.com/gulp-community/gulp-cached" target="_blank" rel="noopener">gulp-cached</a> - in-memory file cache, not for operation on sets of files</li><li><a href="https://github.com/ahaurw01/gulp-remember" target="_blank" rel="noopener">gulp-remember</a> - pairs nicely with gulp-cached</li></ul><h1 id="增量编译"><a href="#增量编译" class="headerlink" title="增量编译"></a>增量编译</h1><h2 id="gulp-lastRun"><a href="#gulp-lastRun" class="headerlink" title="gulp.lastRun()"></a>gulp.lastRun()</h2><p>gulp4提供了lastRun函数用于获取上次运行任务的时间。</p><p>可以使用gulp.src函数的since和gulp.lastRun函数，在运行两次任务之间过滤掉未更改的文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var imgSrc = &apos;src/img/**&apos;;</span><br><span class="line">var imgDest = &apos;build/img&apos;;</span><br><span class="line"></span><br><span class="line">//压缩图片</span><br><span class="line">function images() &#123;</span><br><span class="line">  return gulp.src(imgSrc, &#123;since: gulp.lastRun(images)&#125;)</span><br><span class="line">    .pipe(imagemin(&#123;optimizationLevel: 5&#125;))</span><br><span class="line">    .pipe(gulp.dest(imgDest));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function watch() &#123;</span><br><span class="line">  gulp.watch(imgSrc, images);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;watch&apos;,watch);</span><br></pre></td></tr></table></figure><p>watch任务运行时会将文件保存在内存中，并且在watch任务退出时删除。所以这只会在watch任务执行期间节省images任务的时间。</p><p>如果想要比较两次修改之间的变化，那么就需要使用gulp-changed和gulp-newer两个插件。两者的区别就是gulp-changed通过比较文件的生成和修改的时间，只会将修改过的文件发往下个流，如果后续存在文件合并则会出现文件缺失。所以gulp-changed只适合<strong>一对一</strong>的操作。而如果有<strong>多对一</strong>的情况，则需要使用gulp-newer。</p><h2 id="gulp-changed"><a href="#gulp-changed" class="headerlink" title="gulp-changed"></a>gulp-changed</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function images() &#123;</span><br><span class="line">  return gulp.src(imgSrc)</span><br><span class="line">    .pipe(changed(imgDest))  //只把发生改变或新添加的图片文件发向下个流</span><br><span class="line">    .pipe(imagemin(&#123;optimizationLevel: 5&#125;))</span><br><span class="line">    .pipe(gulp.dest(imgDest));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果文件输出的类型有所不同（sass===&gt;css）需要加上extension参数{extension:’.css’}<br>gulp-changed是基于文件的更改，所以不一定需要使用gulp.watch(),连续使用gulp images命令效果是一样的。<br>gulp-changed只支持<strong>一对一</strong>的文件更新，类似gulp-concat这样合并文件的操作，会有文件内容缺失。</p></blockquote><h2 id="gulp-newer"><a href="#gulp-newer" class="headerlink" title="gulp-newer"></a>gulp-newer</h2><h3 id="1-1输出"><a href="#1-1输出" class="headerlink" title="1:1输出"></a>1:1输出</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function images() &#123;</span><br><span class="line">  return gulp.src(imgSrc)</span><br><span class="line">    .pipe(newer(imgDest))  </span><br><span class="line">    .pipe(imagemin(&#123;optimizationLevel: 5&#125;))</span><br><span class="line">    .pipe(gulp.dest(imgDest));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="many-1输出"><a href="#many-1输出" class="headerlink" title="many:1输出"></a>many:1输出</h3><p>类似gulp-concat这样的插件将多个文件合并成一个。在这种情况下，gulp-newer会把流通过所有文件，如果任何一个文件被更新，gulp-newer就会把他输出到下个流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;concat&apos;, function() &#123;</span><br><span class="line">  return gulp.src(&apos;lib/*.js&apos;)</span><br><span class="line">      .pipe(newer(&apos;dist/all.js&apos;))</span><br><span class="line">      .pipe(concat(&apos;all.js&apos;))</span><br><span class="line">      .pipe(gulp.dest(&apos;dist&apos;));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="gulp-cached"><a href="#gulp-cached" class="headerlink" title="gulp-cached"></a>gulp-cached</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function images() &#123;</span><br><span class="line">  return gulp.src(imgSrc)</span><br><span class="line">    .pipe(cache(&apos;imageMin&apos;))</span><br><span class="line">    .pipe(imagemin(&#123;optimizationLevel: 5&#125;))</span><br><span class="line">    .pipe(gulp.dest(imgDest));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function watch() &#123;</span><br><span class="line">  gulp.watch(imgSrc, images);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;watch&apos;,watch);</span><br></pre></td></tr></table></figure><blockquote><p>gulp-cached基于保存在内存里的数据的对比，关闭了gulp.watch()就没办法对比文件更新。<br>gulp-cached只会把发生改变的文件发往下个流，如果在流的后期需要对所有文件进行操作，那么就需要gulp-remember的配合。</p></blockquote><h2 id="gulp-remember"><a href="#gulp-remember" class="headerlink" title="gulp-remember"></a>gulp-remember</h2><blockquote><p>gulp-remember可以将保存在内存中的所有文件都发向下个流<br>gulp-remember配合使用gulp-cached，可以方便处理当你只想重建那些改变了的文件，但仍然需要对流中的所有文件进行操作的情况。</p></blockquote><p>下面这个案例就是将所有文件合并成一个文件的情况，流的前期用gulp-cached导出那些被修改的文件，后期使用gulp-remember将所有文件导向下个流进行合并操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">    header = require(&apos;gulp-header&apos;),</span><br><span class="line">    footer = require(&apos;gulp-footer&apos;),</span><br><span class="line">    concat = require(&apos;gulp-concat&apos;),</span><br><span class="line">    cache = require(&apos;gulp-cached&apos;),</span><br><span class="line">    remember = require(&apos;gulp-remember&apos;);</span><br><span class="line"></span><br><span class="line">var scriptsGlob = &apos;src/**/*.js&apos;;</span><br><span class="line"></span><br><span class="line">function scripts()&#123;</span><br><span class="line">  return gulp.src(scriptsGlob)</span><br><span class="line">      .pipe(cache(&apos;scripts&apos;)) // 只通过发生改变的文件</span><br><span class="line">      .pipe(header(&apos;(function () &#123;&apos;)) // 在文件头部添加代码&apos;(function () &#123;&apos;</span><br><span class="line">      .pipe(footer(&apos;&#125;)();&apos;)) // 在文件尾部添加代码&apos;&#125;)();&apos;</span><br><span class="line">      .pipe(remember(&apos;scripts&apos;)) // 将所有文件‘召唤’回这个流，其中一些已经被header和footer处理过</span><br><span class="line">      .pipe(concat(&apos;app.js&apos;)) // 合并文件</span><br><span class="line">      .pipe(gulp.dest(&apos;public/&apos;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function watch()&#123;</span><br><span class="line">  var watcher = gulp.watch(scriptsGlob, scripts); </span><br><span class="line">  watcher.on(&apos;change&apos;, function (event) &#123;</span><br><span class="line">    if (event.type === &apos;deleted&apos;) &#123; </span><br><span class="line">      delete cache.caches[&apos;scripts&apos;][event.path];</span><br><span class="line">      remember.forget(&apos;scripts&apos;, event.path);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;watch&apos;,watch);</span><br></pre></td></tr></table></figure><h1 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h1><p>未开启增量编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[18:35:26] Using gulpfile D:\blog\gulpfile.js</span><br><span class="line">[18:35:26] Starting &apos;default&apos;...</span><br><span class="line">[18:35:26] Starting &apos;minifyJS&apos;...</span><br><span class="line">[18:35:26] Starting &apos;minifyHtml&apos;...</span><br><span class="line">[18:35:26] Starting &apos;minifyCss&apos;...</span><br><span class="line">[18:35:26] Starting &apos;minifyImgs&apos;...</span><br><span class="line">[18:35:28] Finished &apos;minifyJS&apos; after 2.2 s</span><br><span class="line">[18:35:29] gulp-imagemin: Minified 17 images (saved 0 B - 0%)</span><br><span class="line">[18:35:29] Finished &apos;minifyImgs&apos; after 3.32 s</span><br><span class="line">[18:35:29] Finished &apos;minifyCss&apos; after 3.66 s</span><br><span class="line">[18:35:30] Finished &apos;minifyHtml&apos; after 4.44 s</span><br><span class="line">[18:35:30] Finished &apos;default&apos; after 4.45 s</span><br></pre></td></tr></table></figure><p>开启增量编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[18:41:27] Using gulpfile D:\blog\gulpfile.js</span><br><span class="line">[18:41:27] Starting &apos;default&apos;...</span><br><span class="line">[18:41:27] Starting &apos;minifyJS&apos;...</span><br><span class="line">[18:41:27] Starting &apos;minifyHtml&apos;...</span><br><span class="line">[18:41:27] Starting &apos;minifyCss&apos;...</span><br><span class="line">[18:41:27] Starting &apos;minifyImgs&apos;...</span><br><span class="line">[18:41:28] Finished &apos;minifyJS&apos; after 879 ms</span><br><span class="line">[18:41:28] gulp-imagemin: Minified 0 images</span><br><span class="line">[18:41:28] Finished &apos;minifyImgs&apos; after 889 ms</span><br><span class="line">[18:41:28] Finished &apos;minifyCss&apos; after 897 ms</span><br><span class="line">[18:41:28] Finished &apos;minifyHtml&apos; after 912 ms</span><br><span class="line">[18:41:28] Finished &apos;default&apos; after 916 ms</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>零配置构建工具：parcel</title>
      <link href="/2018/01/25/%E9%9B%B6%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%EF%BC%9Aparcel/"/>
      <url>/2018/01/25/%E9%9B%B6%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%EF%BC%9Aparcel/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么学习parcel"><a href="#为什么学习parcel" class="headerlink" title="为什么学习parcel"></a>为什么学习parcel</h1><ul><li>17年12月6日，parcel发布了第一个正式版本，目前已经在GitHub上收获了17.7k+个start。</li><li>Parcel是一个Web应用程序打包器(bundler)，与以往使用过的前端构建工具对比，零配置似乎非常具有优势。</li><li>官方表示parcel的打包速度在有cache的情况下，打包速度几乎是webpack的数倍（官方10倍，应该是最佳情况0.0）</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g parcel-bundler</span><br></pre></td></tr></table></figure><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>parcel可以用任何文件作为打包入口，一般推荐使用html或js文件。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>parcel对js，css，html等特定文件有特殊的支持，parcel会自动分析文件中的依赖关系，相同类型的资源被组合在一起成为相同的输出包。如果你在js文件中引入了其他类型的文件（例如css）,那么css依旧会被单独打包，而不是作为内联一并打包到js中。html中的通过链接引入的文件（例如图片，css，js文件）也会被提取并单独打包。</p><p>parcel支持使用CommonJS和ES6的模块语法来到如文件。css支持@import方式引入，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用 CommonJS 语法导入模块</span><br><span class="line">const a = require(&apos;./a&apos;);</span><br><span class="line"></span><br><span class="line">// 使用 ES6 import 语法导入模块</span><br><span class="line">import a from &apos;./a&apos;;</span><br><span class="line"></span><br><span class="line">/* 导入另一个 CSS 文件 */</span><br><span class="line">@import &apos;./a.css&apos;;</span><br></pre></td></tr></table></figure><h1 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h1><p>现在前端项目中使用到的预处理语言及扩展语言越来越多，css预处理语言有less，sass，stylus等，javaScript的扩展语言有TypeScript，CoffeeScript等。还有pug，ejs，jsx，vue等模板，需要在打包时进行转换。</p><p>parcel中已经内置了很多常见的转换和编译器，也可以使用插件来扩展。</p><p>在parcel中使用Babel，PostCSS，PostHTML的方式与其单独使用或与其他打包器配合使用的方式相同。</p><p>先安装到项目中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -D babel-preset-env</span><br><span class="line">npm i -D postcss-modules autoprefixer</span><br><span class="line">npm i -D posthtml-img-autosize</span><br></pre></td></tr></table></figure><p>然后创建配置文件，例如.babelrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码拆分"><a href="#代码拆分" class="headerlink" title="代码拆分"></a>代码拆分</h1><p>若果要将代码分割成多个单独的包以节省加载时间。parcel使用动态import()函数来实现引入和懒加载。用这种方式引入会被拆分成单独的包并且按需加载。</p><p>import()和require()的使用相似，但是import返回的是一个Promise，这意味着它是异步的。</p><p>这可以用在路由配置和页面渲染中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//vue路由</span><br><span class="line">&#123;</span><br><span class="line">     path: &apos;home&apos;,</span><br><span class="line">     component: () =&gt;import(&apos;../pages/home.vue&apos;)</span><br><span class="line">&#125;</span><br><span class="line">//页面渲染</span><br><span class="line">import(&apos;./pages/about&apos;).then(function (page) &#123;</span><br><span class="line">  // 渲染页面</span><br><span class="line">  page.render();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>既然是Promise，这意味着我们可以结合Generator函数（async函数）;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 设置页面名称到动态引入的映射中。</span><br><span class="line">// 在使用前，这些页面都不会被加载。</span><br><span class="line">const pages = &#123;</span><br><span class="line">  about: import(&apos;./pages/about&apos;),</span><br><span class="line">  blog: import(&apos;./pages/blog&apos;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">async function renderPage(page) &#123;</span><br><span class="line">  // 懒加载请求页面。</span><br><span class="line">  const page = await pages[page];</span><br><span class="line">  return page.render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开发和生产环境"><a href="#开发和生产环境" class="headerlink" title="开发和生产环境"></a>开发和生产环境</h1><h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>开发过程中，使用以下命令，会开启代码监听并打开parcel的内置服务器，在浏览器中打开localhost://1234,就可以看到。也可以使用-p命令修改默认端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parcel index.html</span><br></pre></td></tr></table></figure><p>如果有自己的服务器，你可以在watch 模式下运行 Parcel 。当文件改变它仍然会自动重新构建并支持热替换，但是不会启动 web 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parcel watch index.html</span><br></pre></td></tr></table></figure><p>当你准备在生产模式下创建，build 模式会关闭监听并且只建立一次。</p><h2 id="生产模式"><a href="#生产模式" class="headerlink" title="生产模式"></a>生产模式</h2><p>当需要绑定应用程序的时候，你可以使用 Parcel 的生产模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parcel build index.html</span><br></pre></td></tr></table></figure><p>这将关闭监听模式和热模块替换，所以它只会编译一次。它还会开启 minifier 来减少输出包文件的大小。Parcel 使用的 minifiers 有 JavaScript 的 uglify-es ，CSS 的 cssnano 还有 HTML 的 htmlnano。</p><p>启动生产模式还要设置环境变量 NODE_ENV=production 。像 React 这种只用开发调试功能的大型库，通过设置这个环境变量来禁用调试功能，从而构建得更小更快。</p><h1 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h1><ul><li>-p, –port <port>         设置服务器端口</li><li>–https                在https协议上运行</li><li>-o, –open             自动在默认浏览器打开</li><li>-d, –out-dir <path>   设置输入路径默认为dist</li><li>–public-url <url>     设置服务器运行的路劲. 默认与–out-dir option 设置的相同</li><li>–no-hmr               关闭热模块替换</li><li>–no-cache             关闭缓存</li><li>-V, –version          版本信息</li><li>-h, –help             帮助信息</li></ul><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>Parcel 采用与许多其它工具稍微不同的策略，许多常见的格式都被开箱即用地包含进来，而不需要安装或者配置额外的插件。然而，有些情况你可能会想在非标准的情况下扩展 Parcel 的能力，而那些时候，插件是被支持的。安装的插件会基于 package.json 的依赖会被自动检测并加载。parcel插件通常以”parcel-plugin-*”命名。</p><p>目前parcel的插件并不多，常用到的有：</p><ul><li>parcel-plugin-vue</li><li>parcel-plugin-eslint</li><li>parcel-plugin-inlinesvg</li><li>parcel-plugin-pug</li><li>parcel-plugin-typescript</li><li>parcel-plugin-fable</li><li>parcel-plugin-handlebars</li><li>parcel-plugin-svelet</li><li>parcel-plugin-elm</li><li>parcel-plugin-markdown</li><li>parcel-plugin-stylelint</li><li>parcel-plugin-angular</li><li>parcel-plugin-mustache</li></ul><h1 id="零配置打包vue"><a href="#零配置打包vue" class="headerlink" title="零配置打包vue"></a>零配置打包vue</h1><p>项目地址: <a href="https://github.com/w3c-king/parcel-vue" target="_blank" rel="noopener">https://github.com/w3c-king/parcel-vue</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript与正则表达式</title>
      <link href="/2018/01/15/JavaScript%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2018/01/15/JavaScript%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式基础"><a href="#正则表达式基础" class="headerlink" title="正则表达式基础"></a>正则表达式基础</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>正则表达式中有两种字符：</p><p>1.元字符.表达式中的特殊字符</p><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>\t</td><td>水平制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>\n</td><td>换行符</td></tr><tr><td>\r</td><td>回车符</td></tr><tr><td>\0</td><td>空字符</td></tr><tr><td>\f</td><td>换页符</td></tr><tr><td>\cX</td><td>与X对应的控制字符符（Ctrl+X）</td></tr><tr><td>。。。</td><td>。。。</td></tr></tbody></table><p>2.原意文本字符.普通字符，代表原本的意思</p><h2 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h2><ul><li>正则表达式中的字符与待校验字符串中的字符一一对应。</li><li>可以用 [ ] 将一些字符归为一类</li><li>也可以使用^取反，例如[^abc]</li></ul><h2 id="范围类"><a href="#范围类" class="headerlink" title="范围类"></a>范围类</h2><p>如果在字符类中要将每一种情况都列入晓得太麻烦，对于数字和字母可以使用范围类简写，例如：</p><ul><li>[0-9]</li><li>[a-z]</li><li>[a-zA-Z]</li></ul><h2 id="预定义类"><a href="#预定义类" class="headerlink" title="预定义类"></a>预定义类</h2><p>正则表达式还提供了一些预定义类，来对复杂范围类进行概括</p><table><thead><tr><th>字符</th><th>等价</th><th>含义</th></tr></thead><tbody><tr><td>.</td><td>[^\r\n]</td><td>除了回车和换行符外的所有字符</td></tr><tr><td>\d</td><td>[0-9]</td><td>数字字符</td></tr><tr><td>\D</td><td>[^0-9]</td><td>非数字字符</td></tr><tr><td>\s</td><td>[\t\n\x0B\f\r]</td><td>空白符</td></tr><tr><td>\S</td><td>[^\t\n\x0B\f\r]</td><td>非空白符</td></tr><tr><td>\w</td><td>[a-zA-Z_0-9]</td><td>单词字符（数字，字母，下划线）</td></tr><tr><td>\W</td><td>[^a-zA-Z_0-9]</td><td>非单词字符</td></tr></tbody></table><h2 id="字符边界"><a href="#字符边界" class="headerlink" title="字符边界"></a>字符边界</h2><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>^</td><td>以xxx开始</td></tr><tr><td>$</td><td>以xxx结束</td></tr><tr><td>\b</td><td>单词边界</td></tr><tr><td>\B</td><td>非单词边界</td></tr><tr><td>## 量词</td><td></td></tr><tr><td>量词变数所匹配的字符串重复次数</td><td></td></tr></tbody></table><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td>？</td><td>出现零次或一次（最多一次）</td></tr><tr><td>+</td><td>出现一次或多次（至少一次）</td></tr><tr><td>*</td><td>出现零次或多次（任意次）</td></tr><tr><td>{n}</td><td>出现n次</td></tr><tr><td>{n,m}</td><td>出现n到m次</td></tr><tr><td>{n,}</td><td>至少出现n次</td></tr><tr><td>## 贪婪模式与非贪婪模式</td><td></td></tr><tr><td>### 贪婪模式</td><td></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;3,6&#125; //尽可能多匹配,但最多为6次</span><br></pre></td></tr></table></figure></td><td></td></tr><tr><td>### 贪婪模式</td><td></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;3,6&#125;? //尽可能少匹配，但至少为3次</span><br></pre></td></tr></table></figure></td><td></td></tr><tr><td>## 分组</td><td></td></tr><tr><td>使用“()”将匹配规则划分成几个组</td><td></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//&quot;yes&quot;连续出现3次</span><br><span class="line">(yes)&#123;3&#125;</span><br><span class="line"></span><br><span class="line">//或：|，可以匹配yes or no或yes and no</span><br><span class="line">yes\b(or|and)\bno</span><br><span class="line"></span><br><span class="line">//反向应用</span><br><span class="line">&apos;2017-11-1&apos;.replace(/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;0,2&#125;)/,&apos;$3/$2/$1&apos;)</span><br><span class="line">输出：1/11/2017</span><br><span class="line">三个“()”将正则表示时分为三组，每组可以用$n来表示，n即在表达式中出现的次序。该表达式中的三组分别匹配到&quot;2017&quot;、&quot;11&quot;、&quot;1&quot;,该函数将匹配到的字符串用第二个参数替换。$3/$2/$1==&gt;2017/11/1</span><br></pre></td></tr></table></figure></td><td></td></tr><tr><td>## 前瞻</td><td></td></tr><tr><td>前瞻即将匹配到的字符串再向前观察是否也符合所定义的规则,例如校验数字前是否带有“￥”，我们可以使用这个正则表达式：</td><td></td></tr><tr><td><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;0,&#125;(?=￥)</span><br></pre></td></tr></table></figure></td><td></td></tr><tr><td>名称</td><td>规则</td></tr><tr><td>—</td><td>—</td></tr><tr><td>正向前瞻</td><td>exp(?=assert)</td></tr><tr><td>反向前瞻</td><td>exp(?!assert)</td></tr><tr><td>正向后顾</td><td>exp(?&lt;=assert)</td></tr><tr><td>反向后顾</td><td>exp(?&lt;=!assert)</td></tr><tr><td># RegExp对象</td><td></td></tr><tr><td>简而言之，正则表达式就是对比校验字符串是否符合某种规则。</td><td></td></tr></tbody></table><p>RegExp作为JavaScript的内置对象表示JavaScript对正则表达式有着原生的支持。</p><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.使用构造函数</span><br><span class="line">var reg = new RegExp(&apos;\\bimjianjian\\b&apos;,&apos;g&apos;);</span><br><span class="line">2.字面量方式</span><br><span class="line">var reg = /\bimjianjian\b/g</span><br></pre></td></tr></table></figure><p>以上两种方式都能创建js正则表达式对象，都是校验字符串中是否含有 imjianjian 这个单词，\b表示单词边界。且两种方式中都使用了修饰符，构造函数用第二个参数来传入，而字面量则直接写在表达式后。修饰符一共如下三种：</p><ul><li>g。global全文搜索，不写则只匹配字符串中的第一个</li><li>i。ignore case,忽略大小写，不写则大小写敏感</li><li>m。mutiple lines，多行搜索，不写则只搜索第一行</li></ul><h2 id="对象属性"><a href="#对象属性" class="headerlink" title="对象属性"></a>对象属性</h2><ul><li>global:是否全文搜索，默认false</li><li>ignoreCase:是否大小写敏感，默认false</li><li>multiline:多行搜索，默认false</li><li>lastIndex:当前表达式匹配内容的最后一个字符的下一个位置</li><li>source:正则表达式的文本字符串</li></ul><h2 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h2><h3 id="test-string"><a href="#test-string" class="headerlink" title="test(string)"></a>test(string)</h3><p>test() 方法检索字符串中的指定值。返回值是 true 或 false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/\bam\b/.test(&apos;i am jianjian&apos;) //true</span><br><span class="line">/\bam\b/.test(&apos;he is jianjian&apos;) //false</span><br></pre></td></tr></table></figure><h3 id="exec-string"><a href="#exec-string" class="headerlink" title="exec(string)"></a>exec(string)</h3><p>exec() 方法检索字符串中的指定值。返回值是被找到的值。如果没有发现匹配，则返回 null。</p><p>如果需要找到所有某个字符的所有存在，在找到第一个匹配的字符后，将存储其位置。如果再次运行 exec()，则从存储的位置开始检索，并找到下一个匹配字符，并存储其位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;this is jianjian&quot;; </span><br><span class="line">var reg = new RegExp(&quot;is&quot;,&quot;g&quot;);</span><br><span class="line">var result;</span><br><span class="line"></span><br><span class="line">while ((result = reg.exec(str)) != null)  &#123;</span><br><span class="line">  console.log(result);</span><br><span class="line">  console.log(reg.lastIndex);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="conpile-regexp-modifier"><a href="#conpile-regexp-modifier" class="headerlink" title="conpile(regexp,modifier)"></a>conpile(regexp,modifier)</h3><p>compile() 既可以改变检索模式，也可以添加或删除第二个参数。即更改匹配规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg=/man/g;</span><br><span class="line">reg2=/(wo)?man/g;</span><br><span class="line">reg.compile(reg2,&apos;i&apos;);//将匹配规则改为reg2,且大小写不敏感</span><br></pre></td></tr></table></figure><h2 id="string对象中支持使用正则表达式的方法"><a href="#string对象中支持使用正则表达式的方法" class="headerlink" title="string对象中支持使用正则表达式的方法"></a>string对象中支持使用正则表达式的方法</h2><h3 id="search-reg"><a href="#search-reg" class="headerlink" title="search(reg)"></a>search(reg)</h3><p>检索与正则表达式相匹配的值。返回第一个与 regexp 相匹配的子串的起始位置。如果没有找到任何匹配的子串，则返回 -1。search() 方法不执行全局匹配，它将忽略标志 g。它同时忽略 regexp 的 lastIndex 属性，并且总是从字符串的开始进行检索，这意味着它总是返回 stringObject 的第一个匹配的位置。</p><h3 id="match-reg-str"><a href="#match-reg-str" class="headerlink" title="match(reg|str)"></a>match(reg|str)</h3><p>找到一个或多个正则表达式的匹配。返回存放匹配结果的数组。该数组的内容依赖于 regexp 是否具有全局标志 g。</p><h3 id="replace-reg-replacement"><a href="#replace-reg-replacement" class="headerlink" title="replace(reg,replacement)"></a>replace(reg,replacement)</h3><ul><li>reg:正则表达式</li><li>replacement：替换字符</li></ul><p>替换与正则表达式匹配的子串。返回一个新的字符串，是用 replacement 替换了 regexp 的第一次匹配或所有匹配之后得到的。</p><h3 id="split-reg-howmany"><a href="#split-reg-howmany" class="headerlink" title="split(reg,howmany)"></a>split(reg,howmany)</h3><ul><li>reg:正则表达式</li><li>howmany：返回数组最大长度</li></ul><p>按照匹配到的字符作为切割点。返回切割后的数组。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Grunt快速入门</title>
      <link href="/2018/01/14/Grunt%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2018/01/14/Grunt%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>首先，grunt依赖Nodejs和npm环境</li><li>使用npm安装grunt-cli命令行工具</li><li>全局安装<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g grunt-cli</span><br></pre></td></tr></table></figure></li><li>在项目中添加<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install grunt --save-dev</span><br></pre></td></tr></table></figure></li><li>在项目根目录下创建Gruntfile.js文件</li></ul><h1 id="Gruntfile-js文件结构"><a href="#Gruntfile-js文件结构" class="headerlink" title="Gruntfile.js文件结构"></a>Gruntfile.js文件结构</h1><ul><li>一个’wrapper’方法</li><li>配置项目和任务<ul><li>task //任务<ul><li>target //任务子项<ul><li>options //任务的配置参数</li></ul></li></ul></li></ul></li><li>加载grunt插件</li><li>配置任务</li></ul><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><p>作为Task就是一个个任务<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">copy: &#123;</span><br><span class="line">    html: &#123;</span><br><span class="line">        files: [&#123;</span><br><span class="line">            expand: true,</span><br><span class="line">            cwd: &apos;./src/&apos;,</span><br><span class="line">            src: &apos;**/**.html&apos;,</span><br><span class="line">            dest: &apos;./dist/&apos;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    js:&#123;</span><br><span class="line">        files:[&#123;</span><br><span class="line">            expand:true,</span><br><span class="line">            cwd:&apos;./src/&apos;,</span><br><span class="line">            src:&apos;**/**.js&apos;,</span><br><span class="line">            dest:&apos;./dist/&apos;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个任务就是将html和js文件都复制到dist目录下</p><h2 id="target"><a href="#target" class="headerlink" title="target"></a>target</h2><p>而target则是任务中针对不同操作分配的子项，在上述copy任务中，html和js就是两个target，他们分别负责复制不同的文件。</p><h2 id="options"><a href="#options" class="headerlink" title="options"></a>options</h2><p>options就是每个任务的配置项目，在上述的copy任务中，expand,cwd,src,dest都是options</p><h2 id="完整的Gruntfile-js示例"><a href="#完整的Gruntfile-js示例" class="headerlink" title="完整的Gruntfile.js示例"></a>完整的Gruntfile.js示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">//wrapper函数</span><br><span class="line">module.exports = function (grunt) &#123;</span><br><span class="line">    //配置项目和任务</span><br><span class="line">    grunt.initConfig(&#123;</span><br><span class="line">        pkg: grunt.file.readJSON(&apos;package.json&apos;),</span><br><span class="line">        //复制html和图片文件到dist</span><br><span class="line">        copy: &#123;</span><br><span class="line">            html: &#123;</span><br><span class="line">                files: [&#123;</span><br><span class="line">                    expand: true,</span><br><span class="line">                    cwd: &apos;./src/&apos;,</span><br><span class="line">                    src: &apos;**/**.html&apos;,</span><br><span class="line">                    dest: &apos;./dist/&apos;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            js:&#123;</span><br><span class="line">                files:[&#123;</span><br><span class="line">                    expand:true,</span><br><span class="line">                    cwd:&apos;./src/&apos;,</span><br><span class="line">                    src:&apos;**/**.js&apos;,</span><br><span class="line">                    dest:&apos;./dist/&apos;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;,</span><br><span class="line">            images: &#123;</span><br><span class="line">                files: [&#123;</span><br><span class="line">                    expand: true,</span><br><span class="line">                    cwd: &apos;./src/images&apos;,</span><br><span class="line">                    src: &apos;*&apos;,</span><br><span class="line">                    dist: &apos;./dist/images/&apos;,</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        //合并js</span><br><span class="line">        concat:&#123;</span><br><span class="line">            dist: &#123;</span><br><span class="line">                file: &#123;</span><br><span class="line">                    &apos;./dist/js/all.js&apos;:[&apos;./dist/js/a1.js&apos;,&apos;./dist/js/a2.js&apos;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        //sass</span><br><span class="line">        sass: &#123;</span><br><span class="line">            output: &#123;</span><br><span class="line">                files: &#123;</span><br><span class="line">                    &apos;./dist/css/style.css&apos;: &apos;./src/less/a.sass&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        //压缩</span><br><span class="line">        uglify: &#123;</span><br><span class="line">            uglifyjs: &#123;</span><br><span class="line">                files: &#123;</span><br><span class="line">                    &apos;./dist/js/all.js&apos;: [&apos;./dist/js/all.js&apos;]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        //打开服务器</span><br><span class="line">        connect: &#123;</span><br><span class="line">            options: &#123;</span><br><span class="line">                port: 9000,</span><br><span class="line">                open: true,</span><br><span class="line">                livareload: 35729,</span><br><span class="line">                //change this to &apos;0.0.0.0&apos; to access the server from outside</span><br><span class="line">                hostname: &apos;localhost&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            server: &#123;</span><br><span class="line">                options: &#123;</span><br><span class="line">                    port: 9001,</span><br><span class="line">                    base: &apos;./&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //加载插件</span><br><span class="line">    grunt.loadNpmTasks(&apos;grunt-contrib-copy&apos;);</span><br><span class="line">    grunt.loadNpmTasks(&apos;grunt-contrib-concat&apos;);</span><br><span class="line">    grunt.loadNpmTasks(&apos;grunt-contrib-sass&apos;);</span><br><span class="line">    grunt.loadNpmTasks(&apos;grunt-contrib-jshint&apos;);</span><br><span class="line">    grunt.loadNpmTasks(&apos;grunt-contrib-uglify&apos;);</span><br><span class="line">    grunt.loadNpmTasks(&apos;grunt-contrib-watch&apos;);</span><br><span class="line">    grunt.loadNpmTasks(&apos;grunt-contrib-connect&apos;);</span><br><span class="line">    //注册任务</span><br><span class="line">    grunt.registerTask(&apos;copyhtml&apos;, [&apos;copy:html&apos;]); //可以用task：target的方法分别注册</span><br><span class="line">    grunt.registerTask(&apos;concatjs&apos;, [&apos;concat&apos;]); //也可以只用task名称注册，默认执行task下全部target</span><br><span class="line">    grunt.registerTask(&apos;outputcss&apos;, [&apos;sass&apos;]);</span><br><span class="line">    // grunt.registerTask(&apos;watchit&apos;, [&apos;concat&apos;, &apos;sass&apos;, &apos;jshint&apos;, &apos;uglify&apos;, &apos;connect&apos;, &apos;watch&apos;]);</span><br><span class="line">    grunt.registerTask(&apos;default&apos;, [&apos;copy&apos;, &apos;concat&apos;, &apos;sass&apos;, &apos;uglify&apos;]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="配置任务"><a href="#配置任务" class="headerlink" title="配置任务"></a>配置任务</h1><p>任务配置是Gruntfile通过grunt.initConfig方法指定的。这种配置大多会在任务命名的属性下，但可能包含任何任意的数据。只要属性不与任务需要的属性相冲突，它们将被忽略。</p><p>另外，因为这是JavaScript，所以不仅限于JSON。可以在这里使用任何有效的JavaScript。甚至可以编程生成配置，如果有必要的话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  concat: &#123;</span><br><span class="line">    // concat task configuration goes here.</span><br><span class="line">  &#125;,</span><br><span class="line">  uglify: &#123;</span><br><span class="line">    // uglify task configuration goes here.</span><br><span class="line">  &#125;,</span><br><span class="line">  // Arbitrary non-task-specific properties.</span><br><span class="line">  my_property: &apos;whatever&apos;,</span><br><span class="line">  my_src_files: [&apos;foo/*.js&apos;, &apos;bar/*.js&apos;],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="配置task和target-添加options"><a href="#配置task和target-添加options" class="headerlink" title="配置task和target,添加options"></a>配置task和target,添加options</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  concat: &#123;</span><br><span class="line">    options: &#123;</span><br><span class="line">      //task级别的options,会默认执行</span><br><span class="line">    &#125;,</span><br><span class="line">    foo: &#123;</span><br><span class="line">      options: &#123;</span><br><span class="line">        // &quot;foo&quot; 的options，会覆盖task级别的options</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    bar: &#123;</span><br><span class="line">      //没有配置options，将会使用task级别的options</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="文件输入和输出"><a href="#文件输入和输出" class="headerlink" title="文件输入和输出"></a>文件输入和输出</h2><p>src-dest两个options将用于定义他们</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">grunt.initConfig(&#123;</span><br><span class="line">  concat: &#123;</span><br><span class="line">    foo: &#123;</span><br><span class="line">      src:&apos;/src/a.js&apos;,  //可以使用字符串格式</span><br><span class="line">      dest:&apos;/dist/a.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    bar: &#123;</span><br><span class="line">      src:[&apos;/src/a.js&apos;,&apos;/src/aa.js&apos;],  //可以使用数组格式</span><br><span class="line">      dest:&apos;/dist/a.js&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    baz:&#123;</span><br><span class="line">        files:&#123;</span><br><span class="line">            &apos;/dist/a.js&apos;:[&apos;/src/a.js&apos;,&apos;/src/aa.js&apos;] //也可以使用文件对象格式</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    boz:&#123;</span><br><span class="line">        files:[</span><br><span class="line">            &#123;&apos;/dist/a.js&apos;:[&apos;/src/a.js&apos;,&apos;/src/aa.js&apos;]&#125;, //文件对象格式也支持多个src-dest映射</span><br><span class="line">            &#123;&apos;/dist/b.js&apos;:[&apos;/src/b.js&apos;,&apos;/src/bb.js&apos;]&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="Globbing模式"><a href="#Globbing模式" class="headerlink" title="Globbing模式"></a>Globbing模式</h2><p>单独指定所有源文件路径通常是不切实际的，所以Grunt通过内置的node-glob和minimatch库支持文件名扩展（也称为globbing）。</p><p>在文件路径中：</p><ul><li>*匹配任意数量的字符，但不是 /</li><li>?匹配单个字符，但不匹配 /</li><li>**匹配任意数量的字符，包括/只要它是路径部分中唯一的字符</li><li>{}允许逗号分隔的“或”表达式列表</li><li>!在一个模式的开始将忽略这种文件</li></ul><p>所有大多数人需要知道的是，foo/<em>.js将匹配.js在foo/子目录中结束的所有文件，但foo/**/</em>.js将匹配.js在foo/子目录及其所有子目录中结束的所有文件。</p><p>另外，为了简化复杂的通配模式，Grunt允许指定文件路径或Globing模式的数组。模式按顺序处理，!前缀匹配不包括结果集中的匹配文件。结果集是唯一的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 匹配单文件:</span><br><span class="line">&#123;src: &apos;foo/this.js&apos;, dest: ...&#125;</span><br><span class="line">// 匹配数组中的文件:</span><br><span class="line">&#123;src: [&apos;foo/this.js&apos;, &apos;foo/that.js&apos;, &apos;foo/the-other.js&apos;], dest: ...&#125;</span><br><span class="line">// 以th开头的js文件:</span><br><span class="line">&#123;src: &apos;foo/th*.js&apos;, dest: ...&#125;</span><br><span class="line"></span><br><span class="line">// 仅a.js和b.js:</span><br><span class="line">&#123;src: &apos;foo/&#123;a,b&#125;*.js&apos;, dest: ...&#125;</span><br><span class="line">// a,b开头的js文件:</span><br><span class="line">&#123;src: [&apos;foo/a*.js&apos;, &apos;foo/b*.js&apos;], dest: ...&#125;</span><br><span class="line"></span><br><span class="line">// 根目录下的所有js文件:</span><br><span class="line">&#123;src: [&apos;foo/*.js&apos;], dest: ...&#125;</span><br><span class="line">// foo目录下的所有js文件，但是bar.js将优先匹配:</span><br><span class="line">&#123;src: [&apos;foo/bar.js&apos;, &apos;foo/*.js&apos;], dest: ...&#125;</span><br><span class="line"></span><br><span class="line">// 除了bar.js外的所有js文件:</span><br><span class="line">&#123;src: [&apos;foo/*.js&apos;, &apos;!foo/bar.js&apos;], dest: ...&#125;</span><br><span class="line">// 左右js文件，但是bar.js最后匹配.</span><br><span class="line">&#123;src: [&apos;foo/*.js&apos;, &apos;!foo/bar.js&apos;, &apos;foo/bar.js&apos;], dest: ...&#125;</span><br><span class="line"></span><br><span class="line">// 使用模板进行匹配:</span><br><span class="line">&#123;src: [&apos;src/&lt;%= basename %&gt;.js&apos;], dest: &apos;build/&lt;%= basename %&gt;.min.js&apos;&#125;</span><br><span class="line">// 模板也可以引入文件列表:</span><br><span class="line">&#123;src: [&apos;foo/*.js&apos;, &apos;&lt;%= jshint.all.src %&gt;&apos;], dest: ...&#125;</span><br></pre></td></tr></table></figure><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>使用&lt;% %&gt;分隔符指定的模板将在任务从配置中读取时自动展开。递归地扩展模板直到没有更多的剩余。</p><p>整个配置对象是属性被解析的上下文。另外，grunt它的方法在模板中可用，例如。&lt;%= grunt.template.today(‘yyyy-mm-dd’) %&gt;。</p><ul><li>&lt;%= prop.subprop %&gt;prop.subprop无论类型如何，展开到配置中的值。像这样的模板不仅可以用来引用字符串值，还可以用来引用数组或其他对象。</li><li>&lt;% %&gt;执行任意的内联JavaScript代码。这在控制流程或循环中很有用。</li></ul><h2 id="导入外部数据"><a href="#导入外部数据" class="headerlink" title="导入外部数据"></a>导入外部数据</h2><p>grunt由grunt.file.readJSON和grunt.file.readYAML导入JSON和YAML数据的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg: grunt.file.readJSON(&apos;package.json&apos;)</span><br></pre></td></tr></table></figure><h1 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h1><h2 id="注册任务"><a href="#注册任务" class="headerlink" title="注册任务"></a>注册任务</h2><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(taskName, [description, ] taskList)</span><br></pre></td></tr></table></figure><p>默认任务，将在输入grunt之后直接执行,一下任务将在不指定任何人物的情况下执行jshint,qunit,concat,uglify</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(&apos;default&apos;, [&apos;jshint&apos;, &apos;qunit&apos;, &apos;concat&apos;, &apos;uglify&apos;]);</span><br></pre></td></tr></table></figure><p>target可以以被指定,一下任务将在输入grunt dist命令时执行concat的dist target和uglify的dist target</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(&apos;dist&apos;, [&apos;concat:dist&apos;, &apos;uglify:dist&apos;]);</span><br></pre></td></tr></table></figure><h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>当多任务运行时，Grunt在Grunt配置中查找同名的属性(task)。多任务可以有多个配置，使用任意命名的“target”定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerMultiTask(taskName, [description, ] taskFunction)</span><br></pre></td></tr></table></figure><h2 id="自定义任务"><a href="#自定义任务" class="headerlink" title="自定义任务"></a>自定义任务</h2><p>当一个基本任务运行时，Grunt不会查看配置或者环境 - 它只是运行指定的任务函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grunt.registerTask(taskName, [description, ] taskFunction)</span><br></pre></td></tr></table></figure><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>官方api地址：<a href="https://gruntjs.com/api/grunt" target="_blank" rel="noopener">https://gruntjs.com/api/grunt</a></p><p>这里不赘述</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>走进gulp4的世界</title>
      <link href="/2018/01/11/%E8%B5%B0%E8%BF%9Bgulp4%E7%9A%84%E4%B8%96%E7%95%8C/"/>
      <url>/2018/01/11/%E8%B5%B0%E8%BF%9Bgulp4%E7%9A%84%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="gulp简介"><a href="#gulp简介" class="headerlink" title="gulp简介"></a>gulp简介</h1><ul><li>自动化 - gulp是一个工具包，可帮助您在开发工作流程中自动执行痛苦或耗时的任务。</li><li>与平台无关 - 集成被集成到所有主流IDE中，人们正在使用PHP，.NET，Node.js，Java和其他平台。</li><li>强大的生态系统 - 使用npm模块做任何你想要的，拥有超过2000个插件进行流文件转换。</li><li>简单 - 仅提供最少的API，易于学习和使用简单。<br>用gulp对自己的描述就是：Automate and enhance your workflow。</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>要使用gulp要保证你的电脑上要有node环境</p><p>官方建议你这么安装它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//全局安装gulp命令行</span><br><span class="line">$ npm install gulp-cli -g</span><br><span class="line"></span><br><span class="line">//gulp4.0</span><br><span class="line">$ npm install gulp@next -D</span><br><span class="line"></span><br><span class="line">//gulp3.9.1</span><br><span class="line">$ npm install gulp -D </span><br><span class="line"></span><br><span class="line">//创建gulpfile.js文件</span><br><span class="line">$ touch gulpfile.js</span><br><span class="line">$ gulp --help</span><br></pre></td></tr></table></figure><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><ul><li>新的任务系统（基于 bach，替换掉了原先基于 orchestrator 的任务系统）</li><li>移除 gulp.reset</li><li>gulp.task 不再支持三个参数的用法</li><li>gulp.task 用字符串注册的任务必须是直接在命令行中调用的任务</li><li>gulp.task 可以接受单参数语法，这个参数必须是一个命名函数，函数名会被作为任务名</li><li>添加了 gulp.series 和 gulp.parallel 方法用于组合任务</li><li>添加了 gulp.tree 方法用于获取任务树，传入 { deep: true } 参数可以得到一个 archy 兼容的节点列表</li><li>添加了 gulp.registry 方法以定制注册表。</li><li>添加了 gulp.symlink 方法，功能和 gulp.dest 一致，不过是以软链接的方式</li><li>gulp.dest 和 gulp.symlink 方法添加了 dirMode 参数允许对目标目录更好地控制</li><li>gulp.src 接收的文件匹配字符串会顺序解释，所以你可以写成这样 gulp.src([‘<em>.js’, ‘!b</em>.js’, ‘bad.js’])（排除所有以 b 开头的 JS 文件但是除了 bad.js）</li><li>gulp.src 方法添加了 since 选项，筛选在特定时间点之后修改过的文件（用于增量编译）</li><li>将命令行分离出来成为一个独立模块，以便节约带宽/空间。用 npm install gulp -g 或 npm install gulp-cli -g 都可以安装命令行，只是 gulp-cli 不包含模块代码所以比较小</li><li>命令行添加了 –tasks-json 参数，可以导出整个任务树以供他用</li><li>命令行添加了 –verify 参数用以检查 package.json 中是否包含黑名单插件（违背准则而被禁入官方插件列表的可怜娃们）。</li></ul><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>gulp4在gulp3的基础上新增了几个函数，但它的使用依旧简单方便。一共如下10个：</p><ul><li>gulp.src() –全局匹配一个或多个文件</li><li>gulp.dest() –将文件写入目录</li><li>gulp.symlink() –与dest相似，但是使用软连接形式</li><li>gulp.task() –定义任务</li><li>gulp.lastRun() –获得上次成功运行的时间戳</li><li>gulp.parallel() –并行运行任务</li><li>gulp.series() –运行任务序列</li><li>gulp.watch() –当文件发生变化时做某些操作</li><li>gulp.tree() –获得任务书树</li><li>gulp.registry() –获得或注册任务</li></ul><p>官方说明API说明:<a href="https://github.com/gulpjs/gulp/blob/master/docs/API.md" target="_blank" rel="noopener">https://github.com/gulpjs/gulp/blob/master/docs/API.md</a></p><h1 id="task-parallel-and-series"><a href="#task-parallel-and-series" class="headerlink" title="task(parallel and series)"></a>task(parallel and series)</h1><p>gulp4不再能够通过数组形式传入任务，你需要使用gulp.series()和gulp.parallel()来执行他们。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;default&apos;,gulp.parallel(&apos;taskA&apos;,&apos;taskB&apos;));//并行执行</span><br><span class="line">gulp.task(&apos;default&apos;,gulp.series(&apos;taskA&apos;,&apos;taskB&apos;));//按顺序执行</span><br></pre></td></tr></table></figure><p>parallel和series函数可以接受函数作为参数，这意味着我们可以将任务用独立函数表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">funcion taskA()&#123;...&#125;</span><br><span class="line">funcion taskB()&#123;...&#125;</span><br><span class="line"></span><br><span class="line">gulp.task(taskA);//最简单的方式</span><br><span class="line">gulp.task(&apos;i-am-taskB&apos;,taskB);//为taskB添加任务名</span><br><span class="line">gulp.task(&apos;taskA-taskB&apos;, gulp.series(taskA, taskB));//序列执行</span><br><span class="line">gulp.task(&apos;taskA-taskB&apos;, gulp.parallel(taskA，taskB));//并行运行</span><br></pre></td></tr></table></figure><p>而且当我们执行序列化任务时，面板的输出也更加清晰</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PS D:\github\resume&gt; gulp</span><br><span class="line">[21:49:59] Using gulpfile D:\project\gulpfile.js</span><br><span class="line">[21:49:59] Starting &apos;default&apos;...</span><br><span class="line">[21:49:59] Starting &apos;copyfile&apos;...</span><br><span class="line">[21:49:59] Finished &apos;copyfile&apos; after 90 ms</span><br><span class="line">[21:49:59] Starting &apos;minifyhtml&apos;...</span><br><span class="line">[21:49:59] Finished &apos;minifyhtml&apos; after 171 ms</span><br><span class="line">[21:49:59] Starting &apos;minifyCSS&apos;...</span><br><span class="line">[21:50:00] Finished &apos;minifyCSS&apos; after 353 ms</span><br><span class="line">[21:50:00] Starting &apos;uglyfyJS&apos;...</span><br><span class="line">[21:50:01] Finished &apos;uglyfyJS&apos; after 1.43 s</span><br><span class="line">[21:50:01] Finished &apos;default&apos; after 2.05 s</span><br></pre></td></tr></table></figure><h1 id="gulp-lastRun"><a href="#gulp-lastRun" class="headerlink" title="gulp.lastRun()"></a>gulp.lastRun()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">gulp.lastRun(taskName,timeResolution)</span><br><span class="line">参数：</span><br><span class="line">taskName:任务名</span><br><span class="line">timeResolution（可选）:返回的时间戳的精度</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gulp.lastRun(&apos;someTask&apos;, 1000) // 1426000004000.</span><br><span class="line">gulp.lastRun(&apos;someTask&apos;, 100) // 1426000004300.</span><br></pre></td></tr></table></figure><h1 id="gulp-tree"><a href="#gulp-tree" class="headerlink" title="gulp.tree()"></a>gulp.tree()</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语法:</span><br><span class="line">gulp.tree(option)</span><br><span class="line">options：</span><br><span class="line">&#123;</span><br><span class="line">    deep:true/false //是否遍历每个子任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例gulpfile.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(&apos;one&apos;, function(done) &#123;</span><br><span class="line">  // do stuff</span><br><span class="line">  done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;two&apos;, function(done) &#123;</span><br><span class="line">  // do stuff</span><br><span class="line">  done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;three&apos;, function(done) &#123;</span><br><span class="line">  // do stuff</span><br><span class="line">  done();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;four&apos;, gulp.series(&apos;one&apos;, &apos;two&apos;));</span><br><span class="line"></span><br><span class="line">gulp.task(&apos;five&apos;,</span><br><span class="line">  gulp.series(&apos;four&apos;,</span><br><span class="line">    gulp.parallel(&apos;three&apos;, function(done) &#123;</span><br><span class="line">      // do more stuff</span><br><span class="line">      done();</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>实例输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">gulp.tree()</span><br><span class="line"></span><br><span class="line">// output: [ &apos;one&apos;, &apos;two&apos;, &apos;three&apos;, &apos;four&apos;, &apos;five&apos; ]</span><br><span class="line"></span><br><span class="line">gulp.tree(&#123; deep: true &#125;)</span><br><span class="line"></span><br><span class="line">/*output: [</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;label&quot;:&quot;one&quot;,</span><br><span class="line">      &quot;type&quot;:&quot;task&quot;,</span><br><span class="line">      &quot;nodes&quot;:[]</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;label&quot;:&quot;two&quot;,</span><br><span class="line">      &quot;type&quot;:&quot;task&quot;,</span><br><span class="line">      &quot;nodes&quot;:[]</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;label&quot;:&quot;three&quot;,</span><br><span class="line">      &quot;type&quot;:&quot;task&quot;,</span><br><span class="line">      &quot;nodes&quot;:[]</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;label&quot;:&quot;four&quot;,</span><br><span class="line">      &quot;type&quot;:&quot;task&quot;,</span><br><span class="line">      &quot;nodes&quot;:[</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;label&quot;:&quot;&lt;series&gt;&quot;,</span><br><span class="line">            &quot;type&quot;:&quot;function&quot;,</span><br><span class="line">            &quot;nodes&quot;:[</span><br><span class="line">               &#123;</span><br><span class="line">                  &quot;label&quot;:&quot;one&quot;,</span><br><span class="line">                  &quot;type&quot;:&quot;task&quot;,</span><br><span class="line">                  &quot;nodes&quot;:[]</span><br><span class="line">               &#125;,</span><br><span class="line">               &#123;</span><br><span class="line">                  &quot;label&quot;:&quot;two&quot;,</span><br><span class="line">                  &quot;type&quot;:&quot;task&quot;,</span><br><span class="line">                  &quot;nodes&quot;:[]</span><br><span class="line">               &#125;</span><br><span class="line">            ]</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;,</span><br><span class="line">   &#123;</span><br><span class="line">      &quot;label&quot;:&quot;five&quot;,</span><br><span class="line">      &quot;type&quot;:&quot;task&quot;,</span><br><span class="line">      &quot;nodes&quot;:[</span><br><span class="line">         &#123;</span><br><span class="line">            &quot;label&quot;:&quot;&lt;series&gt;&quot;,</span><br><span class="line">            &quot;type&quot;:&quot;function&quot;,</span><br><span class="line">            &quot;nodes&quot;:[</span><br><span class="line">               &#123;</span><br><span class="line">                  &quot;label&quot;:&quot;four&quot;,</span><br><span class="line">                  &quot;type&quot;:&quot;task&quot;,</span><br><span class="line">                  &quot;nodes&quot;:[</span><br><span class="line">                     &#123;</span><br><span class="line">                        &quot;label&quot;:&quot;&lt;series&gt;&quot;,</span><br><span class="line">                        &quot;type&quot;:&quot;function&quot;,</span><br><span class="line">                        &quot;nodes&quot;:[</span><br><span class="line">                           &#123;</span><br><span class="line">                              &quot;label&quot;:&quot;one&quot;,</span><br><span class="line">                              &quot;type&quot;:&quot;task&quot;,</span><br><span class="line">                              &quot;nodes&quot;:[]</span><br><span class="line">                           &#125;,</span><br><span class="line">                           &#123;</span><br><span class="line">                              &quot;label&quot;:&quot;two&quot;,</span><br><span class="line">                              &quot;type&quot;:&quot;task&quot;,</span><br><span class="line">                              &quot;nodes&quot;:[]</span><br><span class="line">                           &#125;</span><br><span class="line">                        ]</span><br><span class="line">                     &#125;</span><br><span class="line">                  ]</span><br><span class="line">               &#125;,</span><br><span class="line">               &#123;</span><br><span class="line">                  &quot;label&quot;:&quot;&lt;parallel&gt;&quot;,</span><br><span class="line">                  &quot;type&quot;:&quot;function&quot;,</span><br><span class="line">                  &quot;nodes&quot;:[</span><br><span class="line">                     &#123;</span><br><span class="line">                        &quot;label&quot;:&quot;three&quot;,</span><br><span class="line">                        &quot;type&quot;:&quot;task&quot;,</span><br><span class="line">                        &quot;nodes&quot;:[]</span><br><span class="line">                     &#125;,</span><br><span class="line">                     &#123;</span><br><span class="line">                        &quot;label&quot;:&quot;&lt;anonymous&gt;&quot;,</span><br><span class="line">                        &quot;type&quot;:&quot;function&quot;,</span><br><span class="line">                        &quot;nodes&quot;:[]</span><br><span class="line">                     &#125;</span><br><span class="line">                  ]</span><br><span class="line">               &#125;</span><br><span class="line">            ]</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h1 id="gulp-load-plugins"><a href="#gulp-load-plugins" class="headerlink" title="gulp-load-plugins"></a>gulp-load-plugins</h1><p>这是一个用于自动加载插件的gulp插件，安装如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-load-plugins -D</span><br></pre></td></tr></table></figure><p>当一个项目需要很多插件来管理的时候，你的gulpfile.js可能会变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;),</span><br><span class="line">    a = require(&apos;gulp-a&apos;), </span><br><span class="line">    b = require(&apos;gulp-b&apos;),</span><br><span class="line">    c = require(&apos;gulp-c&apos;),</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    z = require(&apos;gulp-z&apos;);</span><br></pre></td></tr></table></figure><p>使用gulp-load-plugins可以让你少写一些重复代码，你可以这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(&apos;gulp&apos;);</span><br><span class="line">//加载gulp-load-plugins插件，并马上运行它</span><br><span class="line">var plugins = require(&apos;gulp-load-plugins&apos;)();</span><br><span class="line">//或是：</span><br><span class="line">//var gulpLoadPlugins = require(&apos;gulp-load-plugins&apos;);</span><br><span class="line">//var plugins = gulpLoadPlugins();</span><br></pre></td></tr></table></figure><p>调用插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins.clone() //等价于require(&apos;gulp-clone&apos;)();</span><br></pre></td></tr></table></figure><p>实质上是gulp帮助我们做了如下操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins.clone= require(‘gulp-clone’);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前端构建工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB备份与恢复</title>
      <link href="/2018/01/02/MongoDB%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/"/>
      <url>/2018/01/02/MongoDB%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="MongoDB数据备份"><a href="#MongoDB数据备份" class="headerlink" title="MongoDB数据备份"></a>MongoDB数据备份</h1><b>命令：mongodump</b><p>参数:</p><ul><li><p>-h：<br>服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017。如果不填写，默认是localhost。</p></li><li><p>-p：<br>服务器端口，如果用-h，这个参数可以省略。</p></li><li><p>-d：<br>需要备份的数据库实例，例如：test。不填写该参数会默认备份所有实例。</p></li><li><p>-c:<br>指定备份的数据库的集合(collection),可以和-d配合使用。</p><ul><li>只备份test数据库实例下的a集合：mongodump -d test -c a </li></ul></li><li><p>-f:<br>需要导出的字段,使用方法同上。</p></li><li><p>-o：<br>备份的数据存放位置，例如：c:\data\dump，当然该目录需要提前建立，在备份完成后，系统自动在dump目录下建立一个test目录，这个目录里面存放该数据库实例的备份数据。如果不填这个参数，备份会默认保存在执行当前备份命令的目录下的dump目录里。</p></li></ul><h1 id="MongoDB数据恢复"><a href="#MongoDB数据恢复" class="headerlink" title="MongoDB数据恢复"></a>MongoDB数据恢复</h1><b>命令：mongorestore</b><p>参数：</p><ul><li><p>-h<br>MongoDB所在服务器地址，默认为： localhost:27017</p></li><li><p>-d ：<br>需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2</p></li><li><p>–drop：<br>恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用哦！</p></li><li><p>–dir：<br>指定备份的目录</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB基础操作</title>
      <link href="/2017/12/30/MongoDB%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"/>
      <url>/2017/12/30/MongoDB%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<b>MongoDB版本：3.4</b><h1 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h1><p>find()</p><h2 id="查询所有"><a href="#查询所有" class="headerlink" title="查询所有"></a>查询所有</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(&#123;&#125;)</span><br><span class="line">db.collection.find()</span><br></pre></td></tr></table></figure><h2 id="文档查询"><a href="#文档查询" class="headerlink" title="文档查询"></a>文档查询</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询name=&quot;jianjian&quot;的所有文档</span><br><span class="line">db.collection.find(&#123;&quot;collection&quot;:&quot;jianjian&quot;&#125;)</span><br></pre></td></tr></table></figure><h2 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h2><ul><li>$lt 小于</li><li>$gt 大于</li><li>$gte 大于等于</li><li>$lte 小于等于</li><li>$ne 不等于</li><li>$all 全包含</li><li>$in 包含</li><li>$nin 不包含</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询年龄小于18的</span><br><span class="line">db.collection.find(&quot;age&quot;:&#123;$lt:&quot;18&quot;&#125;)</span><br></pre></td></tr></table></figure><h2 id="all"><a href="#all" class="headerlink" title="$all"></a>$all</h2><p>必须满足所有值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//可以查询出来&#123;age:[20,21,22]&#125;但是查询不出来&#123;age:[20,22,23]&#125;，即一定要有20和21.</span><br><span class="line">db.collection.find(&#123;age:&#123;$all:[20,21]&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="in"><a href="#in" class="headerlink" title="$in"></a>$in</h2><p>这个与$all不一样，查询的值在$in给出的范围之内就都可以查出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//&#123;age:[20,21,22]&#125;,&#123;age:[20,22,23]&#125;都能查出来</span><br><span class="line">db.collection.find(&#123;age:&#123;$in:[20,21]&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="exists"><a href="#exists" class="headerlink" title="$exists"></a>$exists</h2><p>判断key是否存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">判断age字段是否存在</span><br><span class="line">db.collection.find(&#123;age:&#123;$exists:true&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="null值的处理"><a href="#null值的处理" class="headerlink" title="null值的处理"></a>null值的处理</h2><p>null值处理需要注意的是，不仅仅可以查询出来某一字段值为null的记录，还可以查出来不存在某一字段的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(&#123;age:null&#125;)</span><br></pre></td></tr></table></figure><p>可以查询出来age为null的记录，以及没有age字段的记录。如果我们需要只去查询存在age字段并且age字段的值为null的记录，需要配合exists操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(&#123;age:&#123;&quot;$in&quot;:[null],&quot;$exists&quot;:true&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="限制查询条数"><a href="#限制查询条数" class="headerlink" title="限制查询条数"></a>限制查询条数</h2><p>limit(number)</p><p>number为条数 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询条数限制为10条</span><br><span class="line">db.collection.find().limit(10)</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>sort({key:1})</p><p>key为需要排序的字段，升序为1，降序为-1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//按照年龄升序排序</span><br><span class="line">db.collection.find().sort(&#123;&quot;age&quot;:1&#125;)</span><br></pre></td></tr></table></figure><h2 id="跳过记录"><a href="#跳过记录" class="headerlink" title="跳过记录"></a>跳过记录</h2><p>skip()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">查询第10到20条的记录</span><br><span class="line">db.collection.find().skip(10).limit(10);</span><br></pre></td></tr></table></figure><h2 id="查询文档条数"><a href="#查询文档条数" class="headerlink" title="查询文档条数"></a>查询文档条数</h2><p>count()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age大于25的条数</span><br><span class="line">db.collection.find(&#123;age: &#123;$gte: 25&#125;&#125;).count();</span><br></pre></td></tr></table></figure><h1 id="插入文档"><a href="#插入文档" class="headerlink" title="插入文档"></a>插入文档</h1><p>insert()基本语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insert(</span><br><span class="line">   &lt;document or array of documents&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     writeConcern: &lt;document&gt;,</span><br><span class="line">     ordered: &lt;boolean&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="单条插入"><a href="#单条插入" class="headerlink" title="单条插入"></a>单条插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insert(&#123;&quot;name&quot;:&quot;jianjian&quot;&#125;)</span><br></pre></td></tr></table></figure><h2 id="多条插入"><a href="#多条插入" class="headerlink" title="多条插入"></a>多条插入</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insert([&#123;&quot;name&quot;:&quot;jianjian&quot;&#125;,&#123;&quot;name&quot;:&quot;dongdong&quot;&#125;])</span><br></pre></td></tr></table></figure><h2 id="错误的语法"><a href="#错误的语法" class="headerlink" title="错误的语法"></a>错误的语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insert(&#123;&quot;age&quot;:11&#125;,&#123;&quot;age&quot;:12&#125;)</span><br></pre></td></tr></table></figure><p>只有age:11被插入进去，由于接收的插入文档不是数组</p><p>容易误导的地方:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insert([&#123;&quot;name&quot;:&quot;jianjian&quot;&#125;,&#123;&quot;name&quot;:&quot;dongdong&quot;&#125;])</span><br><span class="line"></span><br><span class="line">db.collection.insert(&#123;&quot;name&quot;:&quot;jianjian&quot;&#125;,&#123;&quot;age&quot;:&quot;dongdong&quot;&#125;)</span><br><span class="line"></span><br><span class="line">db.collection.insert(&#123;&quot;name&quot;:&quot;jianjian&quot;,&quot;name&quot;:&quot;dongdong&quot;&#125;)</span><br></pre></td></tr></table></figure><p>第一个插入是插入两个文档，第二个插入是插入一个文档,第三个虽然也是一个文档但是由于键重复，所以只有后一个值会被插入age:12</p><h1 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h1><p>remove() 方法的基本语法格式如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>query  :（可选）删除的文档的条件。</li><li>justOne  : （可选）如果设为 true 或 1，则只删除一个文档。</li><li>writeConcern  :（可选）抛出异常的级别。</li></ul><h2 id="删除num大于100的数据"><a href="#删除num大于100的数据" class="headerlink" title="删除num大于100的数据"></a>删除num大于100的数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.new.remove(&#123;&quot;num&quot;:&#123;$gt:100&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="删除new集合所有数据"><a href="#删除new集合所有数据" class="headerlink" title="删除new集合所有数据"></a>删除new集合所有数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.new.remove(&#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="删除num等于100的数据"><a href="#删除num等于100的数据" class="headerlink" title="删除num等于100的数据"></a>删除num等于100的数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.new.remove(&#123;&quot;num&quot;:100&#125;)</span><br></pre></td></tr></table></figure><h1 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h1><p>update() 方法用于更新已存在的文档。语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>query  : update的查询条件，类似sql update查询内where后面的。</li><li>update  : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的<br>upsert  : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li><li>multi  : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li><li>writeConcern  :可选，抛出异常的级别。</li></ul><h2 id="set修改符"><a href="#set修改符" class="headerlink" title="$set修改符"></a>$set修改符</h2><p>用于修改键的值，如果键不存在就增加键</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//将age=10的数据改成15，默认如果age=10的有多条记录只更新第一条</span><br><span class="line">db.collection.update(&#123;&quot;name&quot;:&quot;li&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:10&#125;&#125;)</span><br><span class="line"></span><br><span class="line">//更新多个满足条件的值,同时如果更新的值不存在就插入更新的值，注意：这里插入的值是20不是30</span><br><span class="line">db.collection.update(&#123;&quot;age&quot;:30&#125;,&#123;$set:&#123;&quot;age&quot;:20&#125;&#125;,&#123;multi:true,upsert:true&#125;)</span><br><span class="line"></span><br><span class="line">可以省略multi,upsert，这里不能有花括号，但是不建议这样做</span><br><span class="line">db.collection.update(&#123;&quot;age&quot;:30&#125;,&#123;$set:&#123;&quot;age&quot;:20&#125;&#125;,true,true)</span><br><span class="line"></span><br><span class="line">//值更新为数组</span><br><span class="line">db.collection.update(&#123;&quot;name&quot;:&quot;zhang&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:[10,</span><br><span class="line">12,14]&#125;&#125;,&#123;upsert:true&#125;)</span><br><span class="line"></span><br><span class="line">//修改为其它的值</span><br><span class="line">db.collection.update(&#123;&quot;name&quot;:&quot;zhang&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:&apos;&apos;&#125;&#125;,&#123;upsert:true&#125;)</span><br><span class="line">db.collection.update(&#123;&quot;name&quot;:&quot;zhang&quot;&#125;,&#123;$set:&#123;&quot;age&quot;:null&#125;&#125;,&#123;upsert:true&#125;)</span><br></pre></td></tr></table></figure><h2 id="inc修改符"><a href="#inc修改符" class="headerlink" title="$inc修改符"></a>$inc修改符</h2><p>用于增加已有键的值，如果键不存在就创建，只能用于整形、长整型、浮点型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//将name=zhang的记录的age键+10</span><br><span class="line">db.collection.update(&#123;&quot;name&quot;:&quot;zhang&quot;&#125;,&#123;$inc:&#123;&quot;age&quot;:10&#125;&#125;,&#123;upsert:true&#125;)</span><br><span class="line"></span><br><span class="line">//将name=zhang的记录的age键-10</span><br><span class="line">db.collection.update(&#123;&quot;name&quot;:&quot;zhang&quot;&#125;,&#123;$inc:&#123;&quot;age&quot;:-10&#125;&#125;,&#123;upsert:true&#125;)</span><br></pre></td></tr></table></figure><h2 id="unset修改符"><a href="#unset修改符" class="headerlink" title="$unset修改符"></a>$unset修改符</h2><p>删除键类似关系数据库的删除字段操作，要区别$set修改符的将键设空或者null值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(&#123;&quot;name&quot;:&quot;zhang&quot;&#125;,&#123;$unset:&#123;&quot;age&quot;:1&#125;&#125;)</span><br></pre></td></tr></table></figure><h2 id="push修改符"><a href="#push修改符" class="headerlink" title="$push修改符"></a>$push修改符</h2><p>如果数组已经存在，“$push”会向已有的数组末尾加入一个元素，要是没有就创建一个新的数组。注意：必须是数组才能加入新的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(&#123;&quot;name&quot;:&quot;zhang&quot;&#125;,&#123;$push:&#123;&quot;comments&quot;:&#123;&quot;email&quot;:&quot;abc@qq.com&quot;,&quot;address&quot;:&quot;beijing&quot;&#125;&#125;&#125;);</span><br><span class="line"></span><br><span class="line">//再插入一条comments</span><br><span class="line">db.collection.update(&#123;&quot;name&quot;:&quot;zhang&quot;&#125;,&#123;$push:&#123;&quot;comments&quot;:&#123;&quot;mark&quot;:&quot;aaa&quot;&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="each修改符"><a href="#each修改符" class="headerlink" title="$each修改符"></a>$each修改符</h2><p>向数组中添加元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insert(&#123;&quot;title&quot;:1,&quot;list&quot;:[1,2,3]&#125;)</span><br><span class="line"></span><br><span class="line">//向list数组中添加单个元素</span><br><span class="line">db.collection.update(&#123;&quot;title&quot;:1&#125;,&#123;$push:&#123;&quot;list&quot;:4&#125;&#125;)</span><br><span class="line"></span><br><span class="line">//向list数组中添加多个元素</span><br><span class="line">db.collection.update(&#123;&quot;title&quot;:1&#125;,&#123;$push:&#123;&quot;list&quot;:&#123;$each:[6,7]&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="addToSet修改符"><a href="#addToSet修改符" class="headerlink" title="$addToSet修改符"></a>$addToSet修改符</h2><p>往数组集中插入元素时，如果元素存在就不插入；方法和$push一样，唯一的区别就是$push不会判断重复值，重复也可以插入。$addToSet也可以结合$each一起使用方法和$push一样可以同时往数组中插入多个元素并且如果元素存在则不插入。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(&#123;&quot;title&quot;:1&#125;,&#123;$addToSet:&#123;&quot;list&quot;:2&#125;&#125;)</span><br><span class="line"></span><br><span class="line">db.collection.update(&#123;&quot;title&quot;:1&#125;,&#123;$addToSet:&#123;&quot;list&quot;:&#123;$each:[2,3,4]&#125;&#125;&#125;);</span><br></pre></td></tr></table></figure><h2 id="pull修改符"><a href="#pull修改符" class="headerlink" title="$pull修改符"></a>$pull修改符</h2><p>匹配数组中的元素将匹配上的元素全部删除，注意只能对数组中的元素进行匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection.insert(&#123;&quot;title&quot;:1,&quot;list&quot;:[1,2,3]&#125;);</span><br><span class="line"></span><br><span class="line">//清除list数组中的元素2</span><br><span class="line">db.collection.update(&#123;&#125;,&#123;$pull:&#123;&quot;list&quot;:2&#125;&#125;)</span><br></pre></td></tr></table></figure><h2 id="pop修改符"><a href="#pop修改符" class="headerlink" title="$pop修改符"></a>$pop修改符</h2><p>从数组的末端或头删除一个元素，$pop:{“list”:1}：从末尾删除一个元素；$pop:{“list”:-1}:从开头删除一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//向数组list中插入两个元素</span><br><span class="line">db.collection.update(&#123;&#125;,&#123;$push:&#123;&quot;list&quot;:&#123;$each:[2,4]&#125;&#125;&#125;);</span><br><span class="line"></span><br><span class="line">//从末尾删除元素</span><br><span class="line">db.collection.update(&#123;&#125;,&#123;$pop:&#123;&quot;list&quot;:1&#125;&#125;);</span><br><span class="line"></span><br><span class="line">//从开头删除元素</span><br><span class="line">db.collection.update(&#123;&#125;,&#123;$pop:&#123;&quot;list&quot;:-1&#125;&#125;);</span><br></pre></td></tr></table></figure><p>基于位置的数组修改方法<br>可以有两种方式来定位数组中的元素：</p><p>1.通过下标；数组的下标都是从0开始。</p><p>2.通过$定位操作符，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.comment.insert(&#123;&quot;title&quot;:1,&quot;comments&quot;:[&#123;&quot;comment&quot;:&quot;a&quot;,&quot;author&quot;:&quot;chen&quot;,&quot;age&quot;:10&#125;,&#123;&quot;comment&quot;:&quot;b&quot;,&quot;author&quot;:&quot;wang&quot;,&quot;age&quot;:30&#125;,&#123;&quot;comment&quot;:&quot;c&quot;,&quot;author&quot;:&quot;zhang&quot;,&quot;age&quot;:40&#125;]&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//将数组中的第一个列表的age值改成20</span><br><span class="line">//方法1：</span><br><span class="line">db.comment.update(&#123;&#125;,&#123;$set:&#123;&quot;comments.0.age&quot;:20&#125;&#125;);</span><br><span class="line"></span><br><span class="line">//方法2：</span><br><span class="line">db.comment.update(&#123;&quot;comments.author&quot;:&quot;chen&quot;&#125;,&#123;$set:&#123;&quot;comments.$.age&quot;:20&#125;&#125;);</span><br></pre></td></tr></table></figure><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。</p><p>这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。</p><p>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构</p><h2 id="ensureIndex-方法"><a href="#ensureIndex-方法" class="headerlink" title="ensureIndex() 方法"></a>ensureIndex() 方法</h2><p>MongoDB使用 ensureIndex() 方法来创建索引。</p><p>设置No为索引：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.collection.ensureIndex(&#123;&quot;No&quot;:1&#125;)</span><br><span class="line">1为指定按升序创建索引，如果你想按降序来创建索引指定为-1即可。</span><br></pre></td></tr></table></figure><h1 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h1><p>删除test集合,注意drop后面的括号里面不需要带花括号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.test.drop()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB安装与配置</title>
      <link href="/2017/12/30/MongoDB%20%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/"/>
      <url>/2017/12/30/MongoDB%20%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<b>MongoDB版本：3.4</b># 一、下载MongoDB<p>官网下载地址：<a href="https://www.mongodb.com/download-center#enterprise" target="_blank" rel="noopener">https://www.mongodb.com/download-center#enterprise</a></p><h1 id="二、配置MongoDB"><a href="#二、配置MongoDB" class="headerlink" title="二、配置MongoDB"></a>二、配置MongoDB</h1><p>有安装版和解压版提供选择，安装后目录结构相同，如下：</p><ul><li>/mongodb<ul><li>/bin</li><li>GNU-AGPL-3.0</li><li>MPL-2</li><li>README</li><li>THIRD-PARTY-NOTICES</li></ul></li></ul><b>将bin目录配置到系统变量path中</b><b>编写mongoDB的配置文件（mongodb.config）</b>文件内容：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//存放数据库文件的地址</span><br><span class="line">dbpath=D:\devSoft\mongodb\db</span><br><span class="line">//存放日志文件的地址</span><br><span class="line">logpath=D:\devSoft\mongodb\log\mongodb.log</span><br></pre></td></tr></table></figure><b>将mongodb服务添加到系统中</b>以管理员启动cmd，输入：<p>mongod –config D:\devSoft\mongodb\mongodb.config –install –serviceName “mongodb”</p><p>这里将–config后的参数配置为上一步所写配置文件的地址</p><p>这里将mongodb服务命名为‘mongodb’</p><b>使用命令启动和关闭mongodb服务</b>net start mongodb //启动服务器<p>net stop mongodb //关闭服务器</p><h1 id="三、MongoDB可视化工具推荐"><a href="#三、MongoDB可视化工具推荐" class="headerlink" title="三、MongoDB可视化工具推荐"></a>三、MongoDB可视化工具推荐</h1><ul><li>MongoDB Cloud Manager</li><li>MongoClient</li><li>adminMongo</li><li>NoSQL Manager for MongoDB</li><li>Robo 3T</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序按钮滑动案例</title>
      <link href="/2017/08/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8C%89%E9%92%AE%E6%BB%91%E5%8A%A8%E6%A1%88%E4%BE%8B/"/>
      <url>/2017/08/25/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8C%89%E9%92%AE%E6%BB%91%E5%8A%A8%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一-先看东西"><a href="#一-先看东西" class="headerlink" title="一.先看东西"></a>一.先看东西</h1><p><img src="http://upload-images.jianshu.io/upload_images/3132358-8ad6afc31cb7849d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="滑动前"></p><p><img src="http://upload-images.jianshu.io/upload_images/3132358-fff67b844cf02fd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="滑动后"></p><h1 id="二-再上代码"><a href="#二-再上代码" class="headerlink" title="二.再上代码"></a>二.再上代码</h1><h2 id="index-wxml"><a href="#index-wxml" class="headerlink" title="index.wxml"></a>index.wxml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;view class=&quot;content&quot;&gt;</span><br><span class="line">    &lt;view class=&quot;sliderContent&quot;&gt;</span><br><span class="line">        &lt;input placeholder=&quot;验证码&quot; placeholder-class=&quot;input-placeholder&quot; disabled=&quot;&#123;&#123;disabled&#125;&#125;&quot; /&gt;</span><br><span class="line">        &lt;view class=&quot;slider&quot; bindtouchstart=&quot;moveSendBtnStart&quot; bindtouchend=&quot;moveSendBtnEnd&quot; bindtouchmove=&quot;moveSendBtn&quot; style=&quot;left:&#123;&#123;moveSendBtnLeft&#125;&#125;rpx;background-color:&#123;&#123;SendBtnColor&#125;&#125;&quot;&gt;发送&lt;/view&gt;</span><br><span class="line">    &lt;/view&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure><h2 id="index-wxss"><a href="#index-wxss" class="headerlink" title="index.wxss"></a>index.wxss</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.content &#123;</span><br><span class="line">    margin-top: 100rpx;</span><br><span class="line">    font-size: 24rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.sliderContent&#123;</span><br><span class="line">    position: relative;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">    margin-bottom: 50rpx;</span><br><span class="line">    padding-left: 60rpx;</span><br><span class="line">    width: 425rpx;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    height: 70rpx;</span><br><span class="line">    line-height: 70rpx;</span><br><span class="line">    border-radius: 60rpx;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    color: #289adc;</span><br><span class="line">    box-shadow: 0px 4px 6px 0px rgba(37, 114, 219, 0.3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.sliderContent input &#123;</span><br><span class="line">    line-height: 70rpx;</span><br><span class="line">    height: 70rpx;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    padding-left: 40rpx;</span><br><span class="line">    width: 250rpx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.input-placeholder &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">    color: #289adc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> .slider &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    width: 150rpx;</span><br><span class="line">    border-radius: 60rpx;</span><br><span class="line">    text-align: center;</span><br><span class="line">    background-color: #7f7f7f;</span><br><span class="line">    color: #fff;</span><br><span class="line">    box-shadow: 0px 4px 6px 0px rgba(37, 114, 219, 0.3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        moveStartX: 0, //起始位置</span><br><span class="line">        moveSendBtnLeft: 0, //发送按钮的left属性</span><br><span class="line">        moveEndX: 0, //结束位置</span><br><span class="line">        screenWidth: 0, //屏幕宽度</span><br><span class="line">        moveable: true, //是否可滑动</span><br><span class="line">        disabled: true,//验证码输入框是否可用,</span><br><span class="line">        SendBtnColor: &quot;#7f7f7f&quot; //滑动按钮颜色</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    onLoad: function () &#123;</span><br><span class="line">        var that = this;</span><br><span class="line">        // 获取屏幕宽度</span><br><span class="line">        wx.getSystemInfo(&#123;</span><br><span class="line">            success: function (res) &#123;</span><br><span class="line">                that.setData(&#123;</span><br><span class="line">                    screenWidth: res.screenWidth</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    //   开始移动</span><br><span class="line">    moveSendBtnStart: function (e) &#123;</span><br><span class="line">        if (!this.data.moveable) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(&quot;start&quot;);</span><br><span class="line">        console.log(e);</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">            moveStartX: e.changedTouches[&quot;0&quot;].clientX</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    //移动发送按钮</span><br><span class="line">    moveSendBtn: function (e) &#123;</span><br><span class="line">        if (!this.data.moveable) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        var that = this;</span><br><span class="line">        // console.log(e.touches[0]);</span><br><span class="line">        var left = ((e.touches[0].clientX - that.data.moveStartX) / (that.data.screenWidth / 750))</span><br><span class="line">        console.log(left)</span><br><span class="line">        if (left &lt;= 275.5) &#123;</span><br><span class="line">            this.setData(&#123;</span><br><span class="line">                moveSendBtnLeft: left</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line"></span><br><span class="line">            this.setData(&#123;</span><br><span class="line">                moveSendBtnLeft: 275.5</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // 结束移动</span><br><span class="line">    moveSendBtnEnd: function (e) &#123;</span><br><span class="line">        console.log(&quot;end&quot;);</span><br><span class="line">        var that = this;</span><br><span class="line">        var left = ((e.changedTouches[0].clientX - that.data.moveStartX) / (that.data.screenWidth / 750))</span><br><span class="line">        console.log(left);</span><br><span class="line">        if (left &lt; 275.5) &#123;</span><br><span class="line">            for (let i = left; i &gt;= 0; i--) &#123;</span><br><span class="line"></span><br><span class="line">                that.setData(&#123;</span><br><span class="line">                    moveSendBtnLeft: i</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            that.setData(&#123;</span><br><span class="line">                moveEndX: e.changedTouches[0].clientX,</span><br><span class="line">                moveable: false,</span><br><span class="line">                disabled: false,</span><br><span class="line">                SendBtnColor: &quot;#289adc&quot;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="三-顺便说说"><a href="#三-顺便说说" class="headerlink" title="三.顺便说说"></a>三.顺便说说</h1><h2 id="1-按钮滑动事件"><a href="#1-按钮滑动事件" class="headerlink" title="1.按钮滑动事件"></a>1.按钮滑动事件</h2><p>bindtouchstart //按钮开始滑动<br>bindtouchend //按钮结束滑动<br>bindtouchmove //按钮正在滑动</p><p>在按钮开始滑动是记录开始的位置<br>滑动结束时要判断按钮是否已经滑动到最右侧，如果只滑动到中间，则弹回</p><p>滑动过程中要计算与初始位置的距离，然后计算并改变button的left属性值</p><h2 id="2-按钮滑动的距离计算"><a href="#2-按钮滑动的距离计算" class="headerlink" title="2.按钮滑动的距离计算"></a>2.按钮滑动的距离计算</h2><p>因为滑动事件返回的数值都是以px作为单位，而我们在界面设计时使用的是rpx，在这里我们要进行数值计算<br>在onLoad中，我们获取到当前设备的宽度<br>rpx作为单位时，认为当前设备的逻辑宽度为750rpx<br>假设屏幕实际宽度为400px，那么1px = 400/750 rpx<br>那么滑动的距离 = 实际互动距离 / （400/750） rpx<br>经过换算后，我们就可以得到以rpx作为单位的滑动距离</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小程序开发遇坑集</title>
      <link href="/2017/08/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%9D%91%E9%9B%86/"/>
      <url>/2017/08/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%AD%E9%81%87%E5%9D%91%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="1-wx-request中的数据加载到页面"><a href="#1-wx-request中的数据加载到页面" class="headerlink" title="1.wx.request中的数据加载到页面"></a>1.wx.request中的数据加载到页面</h1><p>错误方式：      </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var that = this;</span><br><span class="line">      wx.request(&#123;</span><br><span class="line">        url:app.globalData.url.api.home,</span><br><span class="line">        success: function(res) &#123;</span><br><span class="line">            var a= res;</span><br><span class="line">            //这样直接赋值并不会把数据渲染到页面上的    不过 0.9版本的时候这样做是可以的   </span><br><span class="line">            that.data.a=a;</span><br><span class="line">        &#125;&#125;);</span><br></pre></td></tr></table></figure><p>正确方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">that.setData(&#123;a:a;&#125;);</span><br></pre></td></tr></table></figure><h1 id="2-data-XX-数据存取"><a href="#2-data-XX-数据存取" class="headerlink" title="2.data-XX 数据存取"></a>2.data-XX 数据存取</h1><p>官方文档中的错误示范(个人觉得)：</p><p><img src="http://upload-images.jianshu.io/upload_images/3132358-f0029e7b83c7f96e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>正确方式 ：<br>正确的dataset的值是放在currentTarget中的，用targer时常会取不到值<br>应该这样：event.currentTarget.dataset来获取dataset</p><h1 id="3-小程序post写法"><a href="#3-小程序post写法" class="headerlink" title="3.小程序post写法"></a>3.小程序post写法</h1><h2 id="这点在小程序文档中没有解释清楚"><a href="#这点在小程序文档中没有解释清楚" class="headerlink" title="这点在小程序文档中没有解释清楚"></a>这点在小程序文档中没有解释清楚</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wx.request(&#123;</span><br><span class="line">    url: app.globalData.server + &apos;/cart/list.do&apos;,</span><br><span class="line">    header: &#123; &quot;content-type&quot;: &quot;application/x-www-form-urlencoded&quot; &#125;,</span><br><span class="line">    method: &quot;POST&quot;,</span><br><span class="line">    data: Util.json2Form(&#123; cartId: app.globalData.cartId&#125;),</span><br><span class="line">    success:function()&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="json2Form方法"><a href="#json2Form方法" class="headerlink" title="json2Form方法"></a>json2Form方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function json2Form(json) &#123;</span><br><span class="line">    var str = [];</span><br><span class="line">    for (var p in json) &#123;</span><br><span class="line">        str.push(encodeURIComponent(p) + &quot;=&quot; + encodeURIComponent(json[p]));</span><br><span class="line">    &#125;</span><br><span class="line">    return str.join(&quot;&amp;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript模块模式</title>
      <link href="/2017/02/26/JavaScript%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F/"/>
      <url>/2017/02/26/JavaScript%E6%A8%A1%E5%9D%97%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>当一个javascript文件很大的时候，会出现一些问题：<br>1.里面定义了大量的变量，你不得不把变量的名字写的越来越长。<br>2.系统读取全部javascript文件速度很变慢。</p><p>而解决这两个问题最好的有一个很不错的方式就是引入模块模式。</p><h1 id="一、格式"><a href="#一、格式" class="headerlink" title="一、格式"></a>一、格式</h1><p>模块模式使用了匿名闭包的方式</p><p>var model=(function(){<br>   …//定义一些私有变量<br>     return {<br>         ….//以对象的方式返回，返回值可以有函数内部的东西<br>    }<br>})();//可以传参数<br>其中模块内可以定义一些私有变量，return出来的属性是共有属性。</p><h1 id="二、例子"><a href="#二、例子" class="headerlink" title="二、例子"></a>二、例子</h1><p>下面我以学生为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var student=(function(day)&#123;</span><br><span class="line">     var myStudyDay=day;</span><br><span class="line">     function study()&#123;</span><br><span class="line">         myStudyDay++;</span><br><span class="line">     &#125;</span><br><span class="line">     return &#123;</span><br><span class="line">         mygrade:function()&#123;</span><br><span class="line">          return myStudyDay;</span><br><span class="line">        &#125;,</span><br><span class="line">         study:study</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">var qq=student(50);</span><br><span class="line">console.log(qq.mygrade());//50</span><br><span class="line">qq.study();</span><br><span class="line">console.log(qq.mygrade());//51</span><br><span class="line">console.log(myStudyDay);//error:myStudyDay is not defind</span><br></pre></td></tr></table></figure><p>myStudyDay是student模块的私有属性，study是该模块的私有函数，防止了全局污染，在函数外部不能修改这两个的值。</p><h1 id="三、高级"><a href="#三、高级" class="headerlink" title="三、高级"></a>三、高级</h1><p>梦想决定高度，想要让你的模块更大试试这样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var student=(function(day)&#123;</span><br><span class="line">     var myStudyDay=day;</span><br><span class="line">     function study()&#123;</span><br><span class="line">         myStudyDay++;</span><br><span class="line">     &#125;;</span><br><span class="line">     var grade=(function()&#123;</span><br><span class="line">      var grade=90;</span><br><span class="line">      return&#123;</span><br><span class="line">        mygrade:function()&#123;</span><br><span class="line">          return grade</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;)//模块里面套一个模块</span><br><span class="line">     return &#123;</span><br><span class="line">         mygrade:function()&#123;</span><br><span class="line">          return myStudyDay;</span><br><span class="line">        &#125;,</span><br><span class="line">         study:study</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>模块里面套模块，这样可以让你的模块可以变得特别大。</p><p>使用模块模式不仅可以保护一些模块内的变量，同时还可以使我们的代码更具有意义性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript作用域与作用域链</title>
      <link href="/2017/02/26/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/2017/02/26/JavaScript%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、JavaScript作用域"><a href="#一、JavaScript作用域" class="headerlink" title="一、JavaScript作用域"></a>一、JavaScript作用域</h1><p>任何程序设计语言都有作用域的概念，简单的说，作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。</p><h2 id="1-全局作用域-Global-Scope"><a href="#1-全局作用域-Global-Scope" class="headerlink" title="1. 全局作用域(Global Scope)"></a>1. 全局作用域(Global Scope)</h2><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说一下几种情形拥有全局作用域：</p><p>(1)最外层函数和在最外层函数外面定义的变量拥有全局作用域，例如：<br>var authorName=”Burce_zxy”;function doSomething(){var blogName=”旅行的意义zxy”;function innerSay(){alert(blogName);}innerSay();}alert(authorName); //Bruce_zxyalert(blogName); //脚本错误doSomething(); //旅行的意义zxyinnerSay() //脚本错误</p><p>(2)所有末定义直接赋值的变量自动声明为拥有全局作用域，例如：<br>function doSomething(){var authorName=”Bruce_zxy”;blogName=”旅行的意义zxy”;alert(authorName);}alert(blogName); //旅行的意义zxyalert(authorName); //脚本错误<br>变量blogName拥有全局作用域，而authorName在函数外部无法访问到。</p><p>(3)所有window对象的属性拥有全局作用域<br>一般情况下，window对象的内置属性都都拥有全局作用域，例如window.name、window.location、window.top等等。</p><h2 id="2-局部作用域-Local-Scope"><a href="#2-局部作用域-Local-Scope" class="headerlink" title="2. 局部作用域(Local Scope)"></a>2. 局部作用域(Local Scope)</h2><p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域成为函数作用域，例如下列代码中的blogName和函数innerSay都只拥有局部作用域。<br>function doSomething(){var blogName=”旅行的意义zxy”;function innerSay(){alert(blogName);}innerSay();}alert(blogName); //脚本错误innerSay(); //脚本错误</p><h1 id="二、作用域链-Scope-Chain"><a href="#二、作用域链-Scope-Chain" class="headerlink" title="二、作用域链(Scope Chain)"></a>二、作用域链(Scope Chain)</h1><p>在JavaScript中，函数也是对象，实际上，JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是[[Scope]]，由ECMA-262标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。<br>当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。例如定义下面这样一个函数：</p><p>function add(num1,num2) {var sum = num1 + num2;return sum;}<br>在函数add创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量。如下图所示(注意：图片只例举了全部变量中的一部分)：<img src="http://upload-images.jianshu.io/upload_images/3132358-279d0ec7641bda8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>函数add的作用域将会在执行时用到。例如执行如下代码：</p><p>var total = add(5,10);<br>执行此函数时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端，当运行期上下文被销毁，活动对象也随之销毁。新的作用域链如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/3132966-fce8807bd9bbbb26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在函数执行过程中，没遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootstrap之格栅化布局和常用组件</title>
      <link href="/2017/02/17/bootstrap%E4%B9%8B%E6%A0%BC%E6%A0%85%E5%8C%96%E5%B8%83%E5%B1%80%E5%92%8C%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/"/>
      <url>/2017/02/17/bootstrap%E4%B9%8B%E6%A0%BC%E6%A0%85%E5%8C%96%E5%B8%83%E5%B1%80%E5%92%8C%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一-bootstrap-全局css样式-栅格布局系统-重点难点"><a href="#一-bootstrap-全局css样式-栅格布局系统-重点难点" class="headerlink" title="一. bootstrap-全局css样式-栅格布局系统-重点难点"></a>一. bootstrap-全局css样式-栅格布局系统-重点难点</h2><ol><li><p>所有的行必须放在容器中.container或container-fluid</p><pre><code>container  screen&gt;1200px(超大PC显示器-lg)  容器宽1170px  screen&gt;992px(普通PC显示器-md)   容器宽970px  screen&gt;768px(平板显示器-sm)     容器宽750px  screen&lt;768px(手机显示器-xs)     容器宽autocontainer-fluid: width:auto+befor+after</code></pre></li><li><p>分为多行，一行最多分为12列</p></li><li><p>网页内容只能放在列中，不能放到行中</p></li><li><p>可以在col中再嵌套row</p></li><li><p>col分为四大类 col-xs-i col-sm-i col-md-i col-lg-i，  i值可以为1-12，值为某个列的宽度</p></li><li><p>可以为一个列指定不同屏幕下的宽度</p></li><li><p>col-lg-i 大PC<br>   col-md-i 大PC 普通PC<br>   col-sm-i 大PC 普通PC 平板<br>   col-xs-i 大PC 普通PC 平板 手机</p></li><li><p>hidden-lg 大PC<br>   hidden-md 普通PC<br>   hidden-sm 平板<br>   hidden-xs 手机</p></li><li><p>列的偏移问题</p><pre><code>col-xs-offset-i 大PC 普通PC 平板 手机col-sm-offset-i 大PC 普通PC 平板col-md-offset-i 大PC 普通PCcol-lg-offset-i 大PC</code></pre><p>一行中放一列<br>一行中放多列<br>一个行中指定不同宽度的列<br>一个列中指定不同屏幕下的不同宽度<br>不同屏幕下列宽的有效范围</p></li><li><p>使用栅格系统实现响应式布局</p></li><li><p>补充</p><p>  1、 web开发页面布局可以采用的方式</p><pre><code>1) 使用table做布局   简单不易出错，但加载效率低2) HTML+CSS   加载速度快，灵活，不易控制3）使用bootstrap提供的栅格(grid layout)布局系统   加载速度快，灵活，支持响应式功能，容易控制(有行和列的概念)</code></pre><p>  2、 css相关知识</p><pre><code>1) 如何解决父元素的第一个子元素margin-top越界问题   给父元素加border-top   给父元素指定padding-top   给父元素指定overflow:hidden   让该元素不是第一个子元素   为父元素添加前置内容生成-推荐使用    .parent:before {       content:&quot; &quot;;       display:table;    }2) 如果解决所有子元素浮动后，父元素高度变为0，且影响后续元素   给父元素指定overflow:hidden   为父元素指定高度   为父元素添加后置内容生成-推荐使用     .parent:after {       content:&quot;&quot;;       display:table;       clear:both;     }</code></pre><p>  3、 bootstrap系统中容器的特点</p><pre><code>宽度做了媒体查询添加了前置和后置内容生成，可以防止子元素的越界,浮动影响</code></pre></li></ol><h2 id="二-bootstrap-全局css样式-表单-重点难点"><a href="#二-bootstrap-全局css样式-表单-重点难点" class="headerlink" title="二. bootstrap-全局css样式-表单-重点难点"></a>二. bootstrap-全局css样式-表单-重点难点</h2><pre><code>1. bootstrap中的表单分为三种  1) 默认表单        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div class=&quot;form-group&quot;&gt;</span><br><span class="line">     &lt;label class=&quot;control-label&quot;&gt;&lt;/label&gt;</span><br><span class="line"></span><br><span class="line">     &lt;input class=&quot;form-control&quot;&gt;</span><br><span class="line">     &lt;span class=&quot;help-control&quot;&gt;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   </span><br><span class="line">   //bootstrap指定：单选和双选按钮要放到label标签中</span><br><span class="line"></span><br><span class="line">   &lt;div class=&quot;checkbox&quot;&gt;</span><br><span class="line">   &lt;label&gt;</span><br><span class="line">       &lt;input type=&quot;checkbox&quot;&gt;我接受本站的使用条款</span><br><span class="line">   &lt;/label&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>  2) 行内表单     给表单添加form-inline即可  3) 水平表单     默认的栅格系统：container-&gt;row-&gt;col-*     默认的栅格系统：form-horizontal-&gt;form-group-&gt;col-*</code></pre><h2 id="三-bootstrap-组件-图标字体"><a href="#三-bootstrap-组件-图标字体" class="headerlink" title="三. bootstrap-组件-图标字体"></a>三. bootstrap-组件-图标字体</h2><pre><code>1.glyphicons是一套收费的图标字体，提供了web/移动开发中常用的小图标2. bootstrap中可以免费使用这套字体中的250+个，以服务器端字体形式出现的3. 图标字体的本质不是图片，而是字体4. glyphicon 图标字体只能用于空元素-不能包含任何内容或子元素；5. 用法   &lt;span class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/span&gt;   字体文件夹fonts必须跟html文件同级</code></pre><h2 id="四-bootstrap-组件-按钮组"><a href="#四-bootstrap-组件-按钮组" class="headerlink" title="四. bootstrap-组件-按钮组"></a>四. bootstrap-组件-按钮组</h2><pre><code>btn-group 水平按钮组btn-group-vertical 竖直按钮组btn-group btn-group-justified 水平且两端对齐的按钮组btn-group-lgbtn-group-xmbtn-group-xs</code></pre><h2 id="五-bootstrap-组件-下拉菜单-重点简单"><a href="#五-bootstrap-组件-下拉菜单-重点简单" class="headerlink" title="五. bootstrap-组件-下拉菜单 重点简单"></a>五. bootstrap-组件-下拉菜单 重点简单</h2><pre><code>1. 必须html结构   &lt;div class=&quot;dropdown&quot;&gt; 相对定义的父元素     &lt;a data-toggle=&quot;dropdown&quot;&gt;触发元素&lt;/a&gt;     &lt;ul/div class=&quot;dropdown-menu&quot;&gt;隐藏元素&lt;/ul/div&gt;  绝对定位   &lt;/div&gt;2.    divider 分割线   dropdown-header 分类头</code></pre><h2 id="六-bootstrap-组件-导航-重点简单"><a href="#六-bootstrap-组件-导航-重点简单" class="headerlink" title="六. bootstrap-组件-导航  重点简单"></a>六. bootstrap-组件-导航  重点简单</h2><pre><code>1. 标签页导航     &lt;ul class=&quot;nav nav-tabs&quot;&gt;          &lt;li  class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;          &lt;li &gt;&lt;a href=&quot;#&quot;&gt;Profile&lt;/a&gt;&lt;/li&gt;          &lt;li &gt;&lt;a href=&quot;#&quot;&gt;Messages&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    data-toggle=&quot;tab&quot; 用于切换2. 胶囊式导航 用于ul    &lt;ul class=&quot;nav nav-pills&quot;&gt;          &lt;li  class=&quot;active&quot;&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt;          &lt;li &gt;&lt;a href=&quot;#&quot;&gt;Profile&lt;/a&gt;&lt;/li&gt;          &lt;li &gt;&lt;a href=&quot;#&quot;&gt;Messages&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;3. 两端对其的导航 nav nav-tabs nav-justified4. 竖直放置的胶囊导航 nav nav-pills nav-stacked</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式布局学习</title>
      <link href="/2017/02/16/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/02/16/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、响应式网页"><a href="#一、响应式网页" class="headerlink" title="一、响应式网页"></a>一、响应式网页</h1><ol><li><p>一个页面，可以根据浏览设备的不同，以及特性的不同，而自动改变布局、大小等</p></li><li><p>响应式网页的三个特征</p><p>1）流式网格布局(fluid)<br>2）可伸缩的图片和字体<br>3）CSS3 Media Query - 根据客户端浏览设备的特性，有选择的执行部分css</p></li><li><p>优缺点</p><p>  优点：可以自动适配PC/PAD/PHONE浏览器屏幕</p><p>  缺点：代码变复杂，需要考虑更多兼容性，并不适合内容非常多的网页</p></li></ol><h1 id="二、如何测试响应式网页"><a href="#二、如何测试响应式网页" class="headerlink" title="二、如何测试响应式网页"></a>二、如何测试响应式网页</h1><p>   1、真实物理设备</p><pre><code>优点：测试结构真实可靠不足：测试任务量太大</code></pre><p>   2、使用第三方软件</p><pre><code>优点：无需添置真实设备不足：软件测试效率低，部分功能无法测试，测试结果有待进一步验证</code></pre><p>   3、使用浏览器模拟器测试</p><pre><code>优点：测试功能强大，简单易用，不足：测试结果有待进一步验证</code></pre><h1 id="三、响应式布局必须清楚的两个概念"><a href="#三、响应式布局必须清楚的两个概念" class="headerlink" title="三、响应式布局必须清楚的两个概念"></a>三、响应式布局必须清楚的两个概念</h1><pre><code>1. viewport - 视口   1) 2010年之前，html网页基本都是为pc设计的，宽度比较大,在手机上的显示内容会挤压到一块，后来iOSiOS引入了viewport(视口)的概念，来优化手机上观看网站的体验   2)  iOS引入了viewport(视口)的概念：用于显示网页内容的一个逻辑概念，其高度和宽度都可以任意制定，网页不是显示在物理窗口，而是显示在视口中-就可以实现大网页不经缩放，直接显示手机中，但需要用户来回滑动   3) viewport的用法      &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot; &gt;      viewport 可以指定如下属性：         width:  视口的宽度，可以取值为数值，或device-width         height：视口的高度，一般不指定         initial-scale：初始时的缩放倍率         minimum-scale : 允许的最小缩放倍率         maximum-scale :  允许的最大缩放倍率         user-scalable : 是否允许用户手动缩放，可取值1/0/yes/no2. CSS3 media query  1) 作用：根据客户端浏览设备的特性，有选择的执行部分css  2) media: 指浏览网页的设备，如screen  3) Query: 查询出当前浏览设备的特性，如类型、宽度、高度、分辨率、色彩、方向(landscape/portrait)  4) css3MediaQuery有两种用法     根据媒体的特性，加载不同的外部css       &lt;link media=&quot;screen and (min-width:990px) and (max-width:1000px)&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/pc.css&quot;/&gt;       不足：客户端会不管媒体特性，请求所有的css文件     根据媒体的特性，执行某段css中的部分内容       @media screen and (min-width: 990px) {}  https://wangliguang.github.io/categories/</code></pre><h1 id="四、如何编写响应式网页"><a href="#四、如何编写响应式网页" class="headerlink" title="四、如何编写响应式网页"></a>四、如何编写响应式网页</h1><pre><code>1. 在head标签中，声明viewport元标签, 使网页的视口和浏览器的宽高保持一致    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, user-scalable=no&quot; &gt;2. 根据浏览器的不同，加载不同的css文件    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen and (min-width: 400px)&quot; href=&quot;smallScreen.css&quot; /&gt;    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen and (min-width: 400px) and (max-device-width: 600px)&quot; href=&quot;tinyScreen.css&quot; /&gt;3. 同一个css文件中，也根据不同的屏幕分辨率，选择应用不同的css规则    @media screen and (max-device-width: 400px) {    　　　.column {    　　　　　　float: none;    　　　　　　width:auto;    　　　}    　　　#sidebar {    　　　　　　display:none;    　　　}    }4. 注意：   1) 所有元素的宽不能制定固定值，必须使用相对的宽度值    width:&quot;60%&quot; 或者 width:&quot;auto&quot;   2) 字体不能使用绝对大小(px),必须使用相对大小(em)   3) 布局用的各个区块的位置都是浮动的，不是固定不变的   4) 除了布局和文本，还必须实现图片的自动缩放,或者根据客户端屏幕的不同，加载不同尺寸的图片       img {          max-width:100%;        }</code></pre><h1 id="五、-Bootstrap"><a href="#五、-Bootstrap" class="headerlink" title="五、 Bootstrap"></a>五、 Bootstrap</h1><pre><code>www.bootcss.com1. 是一个html/css/js框架，适用于移动设备优先的响应式网页    V2: 面向PC进行了样式设定，同时兼顾pad和phone    V3: 面向Phone进行样式设定，同时兼顾了PC    主要涉及：     HTML: 为H5扩展了一些自定义属性      CSS: CSS Reset + 几千个class     JS: 基于JQ提供了十几个插件函数2. bootstrap分为五部分   1. 起步startup       创建一个bootstrap页面，查看对下述标签进行了哪些样式重置       html body h1-h6 a img table ul   2. 全局css样式 global css       1) 按钮         bootstrap中常用的五种颜色            红色-&gt;危险            绿色-&gt;成功            黄色-&gt;警告            浅蓝色-&gt;信息            深蓝色-&gt;基础的         bootstrap中常用的四个大小              btn-lg -》大               btn-md -》中               btn-sm -》小               btn-xs -》最小         块级按钮              btn-block         调整按钮的位置              pull-right -&gt;右浮动               pull-left  -&gt;左浮动       2) 图片            img-rounded 圆角            img-circle 圆形            img-thumbnail 缩略图            img-responsive 图片支持响应式布局       3) 排版和代码，仅作了解           文本颜色            text-danger            text-success            text-warning            text-info            text-primary           背景颜色            bg-danger            bg-success            bg-warning            bg-info            bg-primary           文本对齐方式             text-left             text-right             text-center             text-justify           文本对齐方式             text-lowercase             text-uppercase             text-capitalize       4) 列表          list-unstyle 去掉列表项样式          list-inline 将所有元素放在同一行       5) 表格           bootlint是一个js，由bootstrap官方提供，用于检测使用bootstrap的页面中场景的html错误，class使用方面的错误-默认请求下浏览器检查不出来的           table           table-bordered 带边框的           table-responsive 响应式表格，注意，使用在table的父元素上，而不是table上           table-striped 隔行变色的表格           table-hover 带悬停效果的表格       6) 栅格布局系统       7) 表单   3. 组件commponent   4. 插件plugin   5. 定制customize</code></pre><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><pre><code>1. 响应式布局就是bootstrap  错的，使用bootstrap是为了更加简单的做响应式页面2. viewport,是一个逻辑概念，可以设置宽高，用于显示页面3. css Media query 根据不同的情况使用不同的css样式4. 自己做响应式页面  1) 设置viewport宽=device-width  2) 使用css3 media query加载样式  3) 注意点     浮动 字体设置相对的 width相对的 img-》max-width:100%5. bootstrap做响应式   1） ie兼容   2）设置viewport   3） 导入关键css文件       css reset + 上千个类   4）使用css hack 让低版本ie兼容html5新标签和cssmediaquery   5） 给元素设置类   6.）导入bootstrap的关键js文件</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jquery中的ajax</title>
      <link href="/2016/12/29/jquery%E4%B8%AD%E7%9A%84ajax/"/>
      <url>/2016/12/29/jquery%E4%B8%AD%E7%9A%84ajax/</url>
      
        <content type="html"><![CDATA[<h1 id="一、封装"><a href="#一、封装" class="headerlink" title="一、封装"></a>一、封装</h1><p>1）封装第一层 - 类似于原生ajax的用法</p><pre><code>$.ajax</code></pre><p>2）封装第二层 - 基于第一层再次封装</p><pre><code>$().load(); $.post();$.get();</code></pre><p>3）封装的第三层 - 特殊用法</p><pre><code>$.getScript(); - 动态读取脚本(js代码)$.getJson();  - 接收json格式数据</code></pre><h1 id="二、load-url-data-callback-方法"><a href="#二、load-url-data-callback-方法" class="headerlink" title="二、load(url,data,callback)方法"></a>二、load(url,data,callback)方法</h1><pre><code>1. 最简单、局限性最大    url - 设置ajax的请求地址    data - 设置ajax的请求数据   data为空时为get方式   data不为空时为post方法   要求为key:value格式，其实就是js的对象格式   callback: ajax请求成功后的回调函数，回调函数的参数就是服务器返回的数据2. 服务器响应的数据自动写入调用load方法的属性中3. load()方法的请求类型   1）没有请求数据时，请求类型是GET   2) 发送请求数据时，请求类型是POST4. load()方法接受服务器端的响应数据   是以字符串类型(HTML格式)来接受</code></pre><h1 id="三、get-post-方法"><a href="#三、get-post-方法" class="headerlink" title="三、get/post()方法"></a>三、get/post()方法</h1><ol><li><p>get(url,data,callback,type)</p><pre><code>1. 参数   url - 设置ajax的请求地址      data - 设置ajax的请求数据      要求为key:value格式，其实就是js的对象格式   callback: ajax请求成功后的回调函数      回调函数的参数就是服务器返回的数据      type:设置服务器端响应的数据格式      默认值为HTML，还可以为xml/json2. 无论是否发送请求数据，请求类型都是GET3. $.get()方法可以接受HTML/XML/JSON格式</code></pre></li><li><p>post(url,data,callback,type)</p><pre><code>使用方式跟get一模一样</code></pre></li></ol><h1 id="四、-ajax-options-方法"><a href="#四、-ajax-options-方法" class="headerlink" title="四、$.ajax(options)方法"></a>四、$.ajax(options)方法</h1><ol><li><p>options的格式是{key:value}</p></li><li><p>url:请求地址</p></li><li><p>type:请求类型，默认为get</p></li><li><p>async:是否异步，默认为true</p></li><li><p>contentType POST方式发送数据的前提，默认值为application/x-www-form-urlencoded</p></li><li><p>data:请求数据，格式必须为key=value</p></li><li><p>success:请求成功后的回调函数</p><pre><code>function(data,textStatus)  data - 服务器响应的内容  textStatus - 表示ajax请求的状态，此时的值为success</code></pre></li><li><p>error:请求失败后的回调函数</p><pre><code>function(XMLHttpRequest,textStatus,errorThrown)  XMLHttpRequest - ajax的核心对象  errorThrown - 错误异常信息  textStatus - 表示ajax请求的状态    error/timeout/notmodified</code></pre></li><li><p>dataType:数据响应格式</p><pre><code>HTML/XML/JSON</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax中的xml和json</title>
      <link href="/2016/12/29/ajax%E4%B8%AD%E7%9A%84xml%E5%92%8Cjson/"/>
      <url>/2016/12/29/ajax%E4%B8%AD%E7%9A%84xml%E5%92%8Cjson/</url>
      
        <content type="html"><![CDATA[<h1 id="ajax中的xml"><a href="#ajax中的xml" class="headerlink" title="ajax中的xml"></a>ajax中的xml</h1><p>   1.请求的数据格式-XML</p><pre><code>1）客户端如何构建XML格式的数据  构建的数据类型 - 字符串类型  字符串的内容要符合XML格式的语法要求2）服务器端如何接受符合XML格式的数据   接收到的客户端的请求数据 - 字符串类型，php集成了DOM的相关内容     DOMDocument     DOMElement     DOMNode</code></pre><p>   2.响应的数据格式-XML</p><pre><code>1）服务器端如何构建符合XML格式的数据    设置服务器端的响应头Content-Type值为text/xml      header(&quot;Content-Type:text/xml&quot;);    构建符合XML格式的数据内容       手动方式构建字符串内容       DOMDocument对象的方法         loadXML(符合XML格式的字符串)         saveXML()方式进行响应2）客户端如何接受XML格式的数据      使用XMLHttpRequest对象的responseXML属性接收      接收到的就是XML DOM对象(不需要进行解析)</code></pre><h1 id="ajax中的json"><a href="#ajax中的json" class="headerlink" title="ajax中的json"></a>ajax中的json</h1><h2 id="一、json"><a href="#一、json" class="headerlink" title="一、json"></a>一、json</h2><p>   1） JSON - javascript object notation(JS原生支持)</p><p>   2） json数据格式源于js</p><p>   3）特点：</p><pre><code>易于程序员阅读和编写易于计算机解析和生成json是目前网络上使用最广泛的数据格式之一</code></pre><p>   4.）JSON的结构</p><pre><code>Array和Object支持的数据类型： 字符串、数值、布尔值、对象、数组、null</code></pre><h2 id="二、ajax中的json格式"><a href="#二、ajax中的json格式" class="headerlink" title="二、ajax中的json格式"></a>二、ajax中的json格式</h2><p>请求格式为json</p><p>1）客户端向服务器端发送请求为json格式的数据</p><pre><code>构建符合JSON格式的字符串定义字符串时，保证里面使用双引号，外面使用单引号</code></pre><p>2）服务器端接受json格式的数据</p><pre><code>使用json_decode()函数进行解析json_decode($json,true);ture代表是否转换为数组</code></pre><p> 响应格式为json</p><p>1） 服务器端向客户发送响应为json格式的数据</p><pre><code>手工方式构建json格式的字符串使用json_encode()函数将php变量(数组)，转换成复合json格式的字符串</code></pre><p>2）客户端接受json格式的数据</p><pre><code>使用XMLHttpRequest对象的responseText属性接受然后使用eval函数进行转换,如果使用()包裹，eval函数强制转换为js代码，var json = eval(&quot;(&quot;+data+&quot;)&quot;);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax基础和xml基础</title>
      <link href="/2016/12/27/ajax%E5%9F%BA%E7%A1%80%E5%92%8Cxml%E5%9F%BA%E7%A1%80/"/>
      <url>/2016/12/27/ajax%E5%9F%BA%E7%A1%80%E5%92%8Cxml%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="一、同步交互与异步交互"><a href="#一、同步交互与异步交互" class="headerlink" title="一、同步交互与异步交互"></a>一、同步交互与异步交互</h2><ol><li><p>客户端想服务器端发送请求，直到服务器端进行响应，这个过程中，用户是不能做任何其他事情的(等)</p></li><li><p>客户端想服务端发送请求，直到服务端进行响应，这个过程中，用户是可以做其他事情的(不用等)</p></li></ol><h2 id="二、AJAX"><a href="#二、AJAX" class="headerlink" title="二、AJAX"></a>二、AJAX</h2><ol><li><p>asynchronous javascript and xml,直译中文-javascript和xml的异步</p></li><li><p>AJAX是一种用来改善用户体验的技术，其实质是，使用XMLHttpRequest对象异步地向服务器发请求</p></li><li><p>服务器返回部分数据，而不是一个完整的页面，以页面无刷新的效果更改页面中的局部内容</p></li><li><p>Ajax的核心对象</p><p>   XMLHttpRequerst对象</p></li><li><p>获取XMLHttpRequest对象</p><p>   function getXhr() {</p><pre><code>var xhr = null;if (window.XMLHttpRequest) {  //除IE外的其他浏览器  xhr = new XMLHttpRequest();} else {  xhr = new ActiveXObject(&quot;Microsoft.XMLHttp&quot;);}  return xhr;</code></pre><p>   }</p></li><li><p>属性</p><pre><code>1) readyState 请求状态   0 尚未初始化   1正在发送请求   2请求完成   3请求成功，正在接受数据   4数据接收成功2) status 请求响应值   200 表示请求成功   202 请求被接受但处理未完成   400 错误的请求   404 资源未找到   500 内部服务器错误，如asp代码错误等3) responseText 服务器返回的文本4) responseXML 服务器返回的xml，可以当做DOM处理</code></pre></li><li><p>方法</p><p>   open(method,url) - 与服务端建立连接</p><p>   send() - 向服务器端发送请求</p><p>   abort() - 取消请求</p><p>   getAllResponseHeaders() - 得到响应的所有http头</p><p>   getResponseHeader() - 获取指定的http头</p><p>   setRequestHeader() - 指定请求的Http头</p></li><li><p>事件</p><p>   onreadystatechange事件 - 作用 - 监听服务端的通信状态改变</p><p>   当Ajax对象的readyState的值发生了改变，比如，从0变成了1，就会产生readystatechange事件</p></li></ol><h2 id="三、实现ajax的异步交互步骤"><a href="#三、实现ajax的异步交互步骤" class="headerlink" title="三、实现ajax的异步交互步骤"></a>三、实现ajax的异步交互步骤</h2><ol><li><p>创建XMLHttpRequest核心对象<br>固定写法-独立编写</p></li><li><p>与服务区建立连接<br>使用XMLHttpRequest对象的open(method,url)</p></li><li><p>向服务器发送请求<br>使用XMLRequest对象的send()方法<br>请求参数的格式 - key=value</p></li><li><p>接受服务器响应的数据</p><p>使用XMLHttpRequest对象的readystatechange事件监听服务器端的通信状态</p><p>使用XMLHttpRequest对象的readyState属性，判断服务器端当前状态(0-4)</p><p>使用XMLHttpRequest对象的statue属性，判断服务器端的状态码(200)</p><p>使用XMLHttp对象的responseText属性，接受服务器端的响应数据</p><p>注意：get与post方式</p><p> get请求方式</p><p>   send()方法不起作用，但是不能被省略<br>   xhr.send(null) 请求参数，添加到url?key=value</p><p> post请求方式</p><p>   必须要在send()方法调用之前，使用setRequestHeader()方法设置请求头，参数为key-value</p><p>   xhr.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”);</p></li></ol><h1 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h1><h2 id="一、接收服务器端的响应数据"><a href="#一、接收服务器端的响应数据" class="headerlink" title="一、接收服务器端的响应数据"></a>一、接收服务器端的响应数据</h2><ol><li><p>使用XMLHttpRequest核心对象的responseText属性</p><p>该属性只能接受文本(HTML)格式</p><p>问题：<br>  解析过程比较复杂，而且在拼串或拆串过程容易出错</p></li><li><p>XML格式的数据</p></li><li><p>json格式的数据</p></li></ol><h2 id="二、XML"><a href="#二、XML" class="headerlink" title="二、XML"></a>二、XML</h2><ol><li><p>HTML/XHTML/DHTML/XML</p><p>HTML: 网页文档<br>XHTML:更严格的网页文档<br>DHTML:DOM|DOM<br>XML: 可扩展的标记语言，可用于配置文件|数据格式</p></li><li><p>XML的文件为.xml</p></li><li><p>XML的定义方式与HTML非常相似</p><p> HTML的元素都是预定义好的<br> XML允许自定义元素</p></li><li><p>XML版本</p><p> 1.0版本  1.1版本，几乎没人使用</p></li><li><p>XML作用</p><p> 作为数据格式-存储数据的地方</p></li><li><p>XML语法</p><p> 1）声明</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;version-设置XML文件的版本encoding-设置XML文件的编码声明必须出现在0行0列上</code></pre><p> 2）定义元素</p><pre><code>根元素，必须是双标签，只能定义一个定义元素，元素名可以自定义，既可以双标签也可以是单标签</code></pre><p> 练习：使用XML定义省份和城市信息</p></li></ol><h2 id="三、DOM解析XML字符串"><a href="#三、DOM解析XML字符串" class="headerlink" title="三、DOM解析XML字符串"></a>三、DOM解析XML字符串</h2><ol><li><p>创建DOM解析XML的解析器，解析器解析XML字符串</p><pre><code>IE浏览器var parser = new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);parser.async = false;xmlDoc = parser.loadXML(xmlFile);其他游览器  var parser = new DOMParser();var xmlDoc = parser.parseFromString(xmlFile,&quot;application/xml&quot;);</code></pre></li><li><p>解析XML元素与解析HTML元素一致</p><p> 获取元素最常用的是getElementsByTagName很少使用ById和ByName</p><p>PS：<br>浏览器不允许读取外部的XML文件<br>浏览器解析符合XML格式的字符串</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web存储和web socket</title>
      <link href="/2016/12/22/web%E5%AD%98%E5%82%A8%E5%92%8Cweb-socket/"/>
      <url>/2016/12/22/web%E5%AD%98%E5%82%A8%E5%92%8Cweb-socket/</url>
      
        <content type="html"><![CDATA[<h1 id="一、web存储"><a href="#一、web存储" class="headerlink" title="一、web存储"></a>一、web存储</h1><ol><li><p>对于任何程序来说，能够实现数据存储是必备功能之一，并且在需要的时候能够提供数据。但在过去的Web客户端，没有能够支持数据存储的有效机制，cookie曾用来在客户端存储少量信息，但受其性质所限，cookie只能存储一些短的字符串</p></li><li><p>在HTML5中提供了Web存储API，它是在cookie之上的增强。这个API允许我们在用户的硬盘上存储数据，并在日后使用这些数据。</p></li><li><p>API可以分成两个部分：</p><p>   1）信息必须且只在会话过程中使用—sessionStorage</p><pre><code>当浏览器窗口关闭时，数据全部丢失</code></pre><p>   2）信息必须长期保存且由用户决定时长—localStorage</p><pre><code>关闭浏览器窗口时，数据继续使用数据只能由用户删除</code></pre></li></ol><h2 id="1-sessionStorage"><a href="#1-sessionStorage" class="headerlink" title="1.sessionStorage"></a>1.sessionStorage</h2><ol><li><p>sessionStorage这部分API就像是会话cookie的替代。</p></li><li><p>cookie以及sessionStorage都是在特定的时间段内保持数据可用。但cookie使用浏览器作为引用，而sessionStorage使用单个窗口作为引用，这就意味着，窗口关闭之后，sessionStorage就不能再使用。</p></li></ol><p>方法：</p><pre><code>1）设置数据   setItem(key,value)   key - 作为存储数据的唯一标识   value - 存储的数据内容(number/string)2) 根据标识获取数据   var value = getItem(key);3) 删除指定标识的数据    removeItem(key);4）将存储系统的所有数据删除    clear()5）根据索引值返回key     var key = key(index);</code></pre><p> 属性：</p><pre><code>返回当前存储系统的数据个数length</code></pre><h2 id="2-localStorage"><a href="#2-localStorage" class="headerlink" title="2.localStorage"></a>2.localStorage</h2><ol><li><p>提供的属性和方法与sessionstorage一致</p></li><li><p>storage事件</p><p>   实现多个窗口之间共享数据内容</p><p>   问题：</p><pre><code>数据安全性低目前除Safari浏览器支持该事件，其他浏览器不支持</code></pre></li></ol><h1 id="二、Web-socket"><a href="#二、Web-socket" class="headerlink" title="二、Web socket"></a>二、Web socket</h1><ol><li><p>网络协议</p><p>   客户端与服务端进行通信的协议</p><p>   HTTP协议 - 目前互联网中最广泛的协议<br>   SOCKET协议 - 应用于实时即时通信</p></li><li><p>HTTP协议的问题</p><pre><code>1）无状态  本次客户端的请求,服务器端不知道客户端的上次请求2）短连接  指通讯双方有数据交互时，就建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。</code></pre></li><li><p>web Socket</p><pre><code>实现了用HTTP不容易实现的服务器端的数据推送等智能通讯技术</code></pre></li><li><p>Web Socket的特点</p><p>1）这个连接是实时的，也是永久的<br>2）服务端可以主动推送消息<br>3）服务端不需要轮询客户端的请求<br>4）服务器端与客户端之间通信无需重新建立连接</p></li><li><p>使用WorkerMan,设置socket客户端</p><p>   1）设置php环境变量</p><p>   2）下载并解压workerMan</p><pre><code>http://www.workerman.net/workermanworkerMan学习文档http://doc3.workerman.net/getting-started/simple-example.html</code></pre><p>   3）在任意位置创建http_test.php文件，并将课件中的start.text文件中内容复制到该文件中（位置任意，能引用到Workerman文件中的Autoloader.php即可</p><p>   4) 运行上建的文件，启动workerMan</p><pre><code>执行workerMan</code></pre></li></ol><h1 id="三、Web-socket的使用"><a href="#三、Web-socket的使用" class="headerlink" title="三、Web socket的使用"></a>三、Web socket的使用</h1><ol><li><p>调用 WebSocket 对象的构造器来建立与服务器之间的通信连接</p><p>   var webSocket = new WebSocket (“ws://127.0.0.1: 8005/socket”) ;</p><p>   请求地址(url)不能再是http://开头,Web Sockets的请求头(url的开头)</p><pre><code>ws:// - Web Socket的缩写wss:// - 表示加密协议</code></pre></li><li><p>使用 WebSocket 对象的 send() 方法对服务器发送数据</p><pre><code>webSocket.send (“data”);send() 方法只能发送文本数据。,使用JSON对象把任何JavaScript,对象转换称文本数据后进行发送。 </code></pre></li><li><p>通过WebSocket对象的close() 方法来关闭socket，切断通信连接：</p><pre><code>webSocket.close( ) ;</code></pre></li><li><p>Web Socket事件</p><p>   1）通过获取 onmessage事件来接收服务器传来的数据：</p><pre><code>webSocket.onmessage = function( event ){  var data = event.data ;}</code></pre><p>   2）通过获取 onopen 事件来监听 socket 的打开事件：</p><pre><code>webSocket.onopen = function( event ){}</code></pre><p>   3）通过获取onclose事件来监听socket 的关闭事件：</p><pre><code>webSocket.onclose = function( event ){}</code></pre><p>   4）通过onerror事件，监听客户端与服务器端连接出错</p><pre><code>webSocket.onerror = function( event ){}</code></pre></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Worker</title>
      <link href="/2016/12/21/Web%20Worker/"/>
      <url>/2016/12/21/Web%20Worker/</url>
      
        <content type="html"><![CDATA[<h1 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h1><h2 id="1-Web-Worker是-运行在后台的javascript-也就是说worker其实就是就一个js文件对象，worker可以让他所包含的js代码运行在后台"><a href="#1-Web-Worker是-运行在后台的javascript-也就是说worker其实就是就一个js文件对象，worker可以让他所包含的js代码运行在后台" class="headerlink" title="1. Web Worker是 运行在后台的javascript,也就是说worker其实就是就一个js文件对象，worker可以让他所包含的js代码运行在后台"></a>1. Web Worker是 运行在后台的javascript,也就是说worker其实就是就一个js文件对象，worker可以让他所包含的js代码运行在后台</h2><h2 id="2-特点："><a href="#2-特点：" class="headerlink" title="2. 特点："></a>2. 特点：</h2><pre><code>1）充分利用多核CPU的优势2）对多线程支持非常好3）不会影响页面的性能4）不能访问web页面和DOM API5）所有的主流浏览器均支持web worker,除了Internet Explorer</code></pre><h2 id="3-Worker提供API"><a href="#3-Worker提供API" class="headerlink" title="3. Worker提供API"></a>3. Worker提供API</h2><pre><code>1）检测当前浏览器是否支持Worker  typeof(Worker) !== &quot;undefined&quot;，如果浏览器返回true，则证明，浏览器支持Worker2）创建Worker文件   创建普通的 JS 文件，都可以用于 Web Worker 文件3）创建Web Worker对象    var worker = new Worker(&quot;myTime.js&quot;);    参数就是在第二步创建的js文件的路径4）worker事件  onmessage事件     用于监听 Web Worker 传递消息，通过回调函数接收传递的消息，通过回调函数的事件对象data 属性可以获取传递的消息  postMessage()     w.postMessage( “worker success.” );     通过postMessage() 方法传递消息内容  w.terminate();     在HTML页面中，通过调用 Web Worker 对象的terminate( ) 方法终止 Web Worker。</code></pre><h1 id="用Worker实线一个简单的计数器"><a href="#用Worker实线一个简单的计数器" class="headerlink" title="用Worker实线一个简单的计数器"></a>用Worker实线一个简单的计数器</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;code&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;button id=&quot;start&quot;&gt;开始计时&lt;/button&gt;</span><br><span class="line">    &lt;button id=&quot;stop&quot;&gt;结束计时&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;br /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div id=&quot;showTime&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var showTime = document.getElementById(&quot;showTime&quot;);</span><br><span class="line">    var start = document.getElementById(&quot;start&quot;).onclick = function() &#123;</span><br><span class="line">        //判断是否支持worker</span><br><span class="line">        if (typeof(Worker) !== &quot;undefined&quot;) &#123;</span><br><span class="line">            //创建js文件，把想运行在后台的js文件放在文件里</span><br><span class="line">            //创建worker对象,并执行内部代码</span><br><span class="line">            worker = new Worker(&quot;mytimer.js&quot;);</span><br><span class="line">            //绑定接受worker传来数据的事件</span><br><span class="line">            worker.onmessage = function(event) &#123;</span><br><span class="line">                showTime.innerHTML = event.data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            console.log(&quot;你的浏览器不支持worker&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var stop = document.getElementById(&quot;stop&quot;).onclick = function() &#123;</span><br><span class="line">        //终止worker</span><br><span class="line">        worker.terminate();</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line">&lt;/code&gt;</span><br></pre></td></tr></table></figure><h1 id="mytimer-js文件"><a href="#mytimer-js文件" class="headerlink" title="mytimer.js文件"></a>mytimer.js文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var time = 0;</span><br><span class="line"></span><br><span class="line">function timer() &#123;</span><br><span class="line">    time++;</span><br><span class="line">    //从worker中发送数据</span><br><span class="line">    //worker中的全局变量，就是worker对象</span><br><span class="line">    postMessage(time);</span><br><span class="line">    console.log(time);</span><br><span class="line">    setTimeout(timer, 1000);</span><br><span class="line">&#125;</span><br><span class="line">timer();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> web前端 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
