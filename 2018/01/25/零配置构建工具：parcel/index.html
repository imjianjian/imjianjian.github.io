<!DOCTYPE html><html lang=""><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="ie=edge"><meta name="author" content="jianjian"><title>零配置构建工具：parcel | imjianjian</title><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script src="/js/script.js"></script><script src="/js/tocbot.min.js"></script></head><body><div class="wrapper"><header><nav class="navbar"><div class="container"><div class="navbar-header header-logo"><a href="/">imjianjian&#39;s Blog</a></div><div class="menu navbar-right"> <a class="menu-item" href="/archives">Posts</a> <a class="menu-item" href="/tags">Tags</a> <input id="switch_default" type="checkbox" class="switch_default"><label for="switch_default" class="toggleBtn"></label></div></div></nav><nav class="navbar-mobile" id="nav-mobile"><div class="container"><div class="navbar-header"><div> <a href="/">imjianjian&#39;s Blog</a><a id="mobile-toggle-theme">·&nbsp;Light</a></div><div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div></div><div class="menu" id="mobile-menu"> <a class="menu-item" href="/archives">Posts</a> <a class="menu-item" href="/tags">Tags</a></div></div></nav></header><script>var mobileBtn=function(){var e=document.getElementsByClassName("menu-toggle")[0],t=document.getElementById("mobile-menu");e.classList.contains("active")?(e.classList.remove("active"),t.classList.remove("active")):(e.classList.add("active"),t.classList.add("active"))}</script><div class="main"><div class="container"><div class="post-toc"><div class="tocbot-list"></div><div class="tocbot-list-menu"> <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a> <a onclick="go_top()">Back to top</a> <a onclick="go_bottom()">Go to bottom</a></div></div><script>function expand_toc(){var o=document.querySelector(".tocbot-toc-expand");tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:6,orderedList:!1,scrollSmooth:!0}),o.setAttribute("onclick","collapse_toc()"),o.innerHTML="Collapse all"}function collapse_toc(){var o=document.querySelector(".tocbot-toc-expand");tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:1,orderedList:!1,scrollSmooth:!0}),o.setAttribute("onclick","expand_toc()"),o.innerHTML="Expand all"}function go_top(){window.scrollTo(0,0)}function go_bottom(){window.scrollTo(0,document.body.scrollHeight)}document.ready(function(){tocbot.init({tocSelector:".tocbot-list",contentSelector:".post-content",headingSelector:"h1, h2, h3, h4, h5",collapseDepth:1,orderedList:!1,scrollSmooth:!0})})</script><article class="post-wrap"><header class="post-header"><h1 class="post-title">零配置构建工具：parcel</h1><div class="post-meta"> Author: <a itemprop="author" rel="author" href="/">jianjian</a> <span class="post-time">Date: <a href="#">January 25, 2018&nbsp;&nbsp;16:13:53</a></span></div></header><div class="post-content"><h1 id="为什么学习parcel"><a href="#为什么学习parcel" class="headerlink" title="为什么学习parcel"></a>为什么学习parcel</h1><ul><li>17年12月6日，parcel发布了第一个正式版本，目前已经在GitHub上收获了17.7k+个start。</li><li>Parcel是一个Web应用程序打包器(bundler)，与以往使用过的前端构建工具对比，零配置似乎非常具有优势。</li><li>官方表示parcel的打包速度在有cache的情况下，打包速度几乎是webpack的数倍（官方10倍，应该是最佳情况0.0）</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g parcel-bundler</span><br></pre></td></tr></table></figure><h1 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h1><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>parcel可以用任何文件作为打包入口，一般推荐使用html或js文件。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>parcel对js，css，html等特定文件有特殊的支持，parcel会自动分析文件中的依赖关系，相同类型的资源被组合在一起成为相同的输出包。如果你在js文件中引入了其他类型的文件（例如css）,那么css依旧会被单独打包，而不是作为内联一并打包到js中。html中的通过链接引入的文件（例如图片，css，js文件）也会被提取并单独打包。</p><p>parcel支持使用CommonJS和ES6的模块语法来到如文件。css支持@import方式引入，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 使用 CommonJS 语法导入模块</span><br><span class="line">const a = require(&apos;./a&apos;);</span><br><span class="line"></span><br><span class="line">// 使用 ES6 import 语法导入模块</span><br><span class="line">import a from &apos;./a&apos;;</span><br><span class="line"></span><br><span class="line">/* 导入另一个 CSS 文件 */</span><br><span class="line">@import &apos;./a.css&apos;;</span><br></pre></td></tr></table></figure><h1 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h1><p>现在前端项目中使用到的预处理语言及扩展语言越来越多，css预处理语言有less，sass，stylus等，javaScript的扩展语言有TypeScript，CoffeeScript等。还有pug，ejs，jsx，vue等模板，需要在打包时进行转换。</p><p>parcel中已经内置了很多常见的转换和编译器，也可以使用插件来扩展。</p><p>在parcel中使用Babel，PostCSS，PostHTML的方式与其单独使用或与其他打包器配合使用的方式相同。</p><p>先安装到项目中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i -D babel-preset-env</span><br><span class="line">npm i -D postcss-modules autoprefixer</span><br><span class="line">npm i -D posthtml-img-autosize</span><br></pre></td></tr></table></figure><p>然后创建配置文件，例如.babelrc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [&quot;env&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="代码拆分"><a href="#代码拆分" class="headerlink" title="代码拆分"></a>代码拆分</h1><p>若果要将代码分割成多个单独的包以节省加载时间。parcel使用动态import()函数来实现引入和懒加载。用这种方式引入会被拆分成单独的包并且按需加载。</p><p>import()和require()的使用相似，但是import返回的是一个Promise，这意味着它是异步的。</p><p>这可以用在路由配置和页面渲染中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//vue路由</span><br><span class="line">&#123;</span><br><span class="line">     path: &apos;home&apos;,</span><br><span class="line">     component: () =&gt;import(&apos;../pages/home.vue&apos;)</span><br><span class="line">&#125;</span><br><span class="line">//页面渲染</span><br><span class="line">import(&apos;./pages/about&apos;).then(function (page) &#123;</span><br><span class="line">  // 渲染页面</span><br><span class="line">  page.render();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>既然是Promise，这意味着我们可以结合Generator函数（async函数）;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 设置页面名称到动态引入的映射中。</span><br><span class="line">// 在使用前，这些页面都不会被加载。</span><br><span class="line">const pages = &#123;</span><br><span class="line">  about: import(&apos;./pages/about&apos;),</span><br><span class="line">  blog: import(&apos;./pages/blog&apos;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">async function renderPage(page) &#123;</span><br><span class="line">  // 懒加载请求页面。</span><br><span class="line">  const page = await pages[page];</span><br><span class="line">  return page.render();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开发和生产环境"><a href="#开发和生产环境" class="headerlink" title="开发和生产环境"></a>开发和生产环境</h1><h2 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h2><p>开发过程中，使用以下命令，会开启代码监听并打开parcel的内置服务器，在浏览器中打开localhost://1234,就可以看到。也可以使用-p命令修改默认端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parcel index.html</span><br></pre></td></tr></table></figure><p>如果有自己的服务器，你可以在watch 模式下运行 Parcel 。当文件改变它仍然会自动重新构建并支持热替换，但是不会启动 web 服务。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parcel watch index.html</span><br></pre></td></tr></table></figure><p>当你准备在生产模式下创建，build 模式会关闭监听并且只建立一次。</p><h2 id="生产模式"><a href="#生产模式" class="headerlink" title="生产模式"></a>生产模式</h2><p>当需要绑定应用程序的时候，你可以使用 Parcel 的生产模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parcel build index.html</span><br></pre></td></tr></table></figure><p>这将关闭监听模式和热模块替换，所以它只会编译一次。它还会开启 minifier 来减少输出包文件的大小。Parcel 使用的 minifiers 有 JavaScript 的 uglify-es ，CSS 的 cssnano 还有 HTML 的 htmlnano。</p><p>启动生产模式还要设置环境变量 NODE_ENV=production 。像 React 这种只用开发调试功能的大型库，通过设置这个环境变量来禁用调试功能，从而构建得更小更快。</p><h1 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h1><ul><li>-p, –port<port> 设置服务器端口</port></li><li>–https 在https协议上运行</li><li>-o, –open 自动在默认浏览器打开</li><li>-d, –out-dir<path> 设置输入路径默认为dist</path></li><li>–public-url<url> 设置服务器运行的路劲. 默认与–out-dir option 设置的相同</url></li><li>–no-hmr 关闭热模块替换</li><li>–no-cache 关闭缓存</li><li>-V, –version 版本信息</li><li>-h, –help 帮助信息</li></ul><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>Parcel 采用与许多其它工具稍微不同的策略，许多常见的格式都被开箱即用地包含进来，而不需要安装或者配置额外的插件。然而，有些情况你可能会想在非标准的情况下扩展 Parcel 的能力，而那些时候，插件是被支持的。安装的插件会基于 package.json 的依赖会被自动检测并加载。parcel插件通常以”parcel-plugin-*”命名。</p><p>目前parcel的插件并不多，常用到的有：</p><ul><li>parcel-plugin-vue</li><li>parcel-plugin-eslint</li><li>parcel-plugin-inlinesvg</li><li>parcel-plugin-pug</li><li>parcel-plugin-typescript</li><li>parcel-plugin-fable</li><li>parcel-plugin-handlebars</li><li>parcel-plugin-svelet</li><li>parcel-plugin-elm</li><li>parcel-plugin-markdown</li><li>parcel-plugin-stylelint</li><li>parcel-plugin-angular</li><li>parcel-plugin-mustache</li></ul><h1 id="零配置打包vue"><a href="#零配置打包vue" class="headerlink" title="零配置打包vue"></a>零配置打包vue</h1><p>项目地址: <a href="https://github.com/w3c-king/parcel-vue" target="_blank" rel="noopener">https://github.com/w3c-king/parcel-vue</a></p></div><section class="post-copyright"><p class="copyright-item"> <span>Author:</span> <span>jianjian</span></p><p class="copyright-item"> <span>Permalink:</span> <span><a href="http://yoursite.com/2018/01/25/%E9%9B%B6%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%EF%BC%9Aparcel/">http://yoursite.com/2018/01/25/%E9%9B%B6%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%EF%BC%9Aparcel/</a></span></p><p class="copyright-item"> <span>License:</span> <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC-BY-NC-4.0</a> LICENSE</span></p><p class="copyright-item"> <span>Slogan:</span> <span>Do you believe in <strong>DESTINY<strong>?</strong></strong></span></p></section><section class="post-tags"><div> <span>Tag(s):</span> <span class="tag"><a href="/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"># 前端构建工具</a></span></div><div> <a href="javascript:window.history.back();" target="_blank" rel="noopener">back</a> <span>·</span> <a href="/">home</a></div></section><section class="post-nav"> <a class="prev" rel="prev" href="/2018/01/31/gulp4%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/">gulp4增量编译</a> <a class="next" rel="next" href="/2018/01/15/JavaScript%E4%B8%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">JavaScript与正则表达式</a></section></article></div></div><footer id="footer" class="footer"><div class="copyright"> <span>© jianjian | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span></div></footer></div></body></html>