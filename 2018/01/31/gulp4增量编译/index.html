<!DOCTYPE html><html><head><meta charset=UTF-8><meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=author content=jianjian><title>gulp4增量编译 | imjianjian</title><link rel=icon href=/favicon.ico><link rel=stylesheet href=/css/style.css><script src=/js/script.js></script><script src=/js/tocbot.min.js></script></head><body><div class=wrapper><header><nav class=navbar><div class=container><div class="navbar-header header-logo"><a href="/">imjianjian&#39;s Blog</a></div><div class="menu navbar-right"><a class=menu-item href=/archives>Posts</a> <a class=menu-item href=/tags>Tags</a> <input id=switch_default type=checkbox class=switch_default><label for=switch_default class=toggleBtn></label></div></div></nav><nav class=navbar-mobile id=nav-mobile><div class=container><div class=navbar-header><div><a href="/">imjianjian&#39;s Blog</a><a id=mobile-toggle-theme>·&nbsp;Light</a></div><div class=menu-toggle onclick=mobileBtn()>&#9776; Menu</div></div><div class=menu id=mobile-menu><a class=menu-item href=/archives>Posts</a> <a class=menu-item href=/tags>Tags</a></div></div></nav></header><script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script><div class=main><div class=container><div class=post-toc><div class=tocbot-list></div><div class=tocbot-list-menu><a class=tocbot-toc-expand onclick=expand_toc()>Expand all</a> <a onclick=go_top()>Back to top</a> <a onclick=go_bottom()>Go to bottom</a></div></div><script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script><article class=post-wrap><header class=post-header><h1 class=post-title>gulp4增量编译</h1><div class=post-meta>Author: <a itemprop=author rel=author href="/">jianjian</a> <span class=post-time>Date: <a href=#>January 31, 2018&nbsp;&nbsp;15:52:19</a></span></div></header><div class=post-content><p>在任何构建工具中增量编译都是一个必不可少的优化方式。即在编译过程中仅编译那些修改过的文件，可以减少许多不必要的资源消耗，也能减少编译时常。而且gulp是一个配置简单，学习性价比很高的工具。</p><h1 id=插件><a href=#插件 class=headerlink title=插件></a>插件</h1><p>在gulp官方推荐了四个插件用于增量编译：</p><ul><li><a href=https://github.com/sindresorhus/gulp-changed target=_blank rel=noopener>gulp-changed</a> - only pass through changed files</li><li><a href=https://github.com/tschaub/gulp-newer target=_blank rel=noopener>gulp-newer</a> - pass through newer source files only, supports many:1 source:dest</li><li><a href=https://github.com/gulp-community/gulp-cached target=_blank rel=noopener>gulp-cached</a> - in-memory file cache, not for operation on sets of files</li><li><a href=https://github.com/ahaurw01/gulp-remember target=_blank rel=noopener>gulp-remember</a> - pairs nicely with gulp-cached</li></ul><h1 id=增量编译><a href=#增量编译 class=headerlink title=增量编译></a>增量编译</h1><h2 id=gulp-lastRun><a href=#gulp-lastRun class=headerlink title=gulp.lastRun()></a>gulp.lastRun()</h2><p>gulp4提供了lastRun函数用于获取上次运行任务的时间。</p><p>可以使用gulp.src函数的since和gulp.lastRun函数，在运行两次任务之间过滤掉未更改的文件：</p><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre></td><td class=code><pre><span class=line>var imgSrc = &apos;src/img/**&apos;;</span><br><span class=line>var imgDest = &apos;build/img&apos;;</span><br><span class=line></span><br><span class=line>//压缩图片</span><br><span class=line>function images() &#123;</span><br><span class=line>  return gulp.src(imgSrc, &#123;since: gulp.lastRun(images)&#125;)</span><br><span class=line>    .pipe(imagemin(&#123;optimizationLevel: 5&#125;))</span><br><span class=line>    .pipe(gulp.dest(imgDest));</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>function watch() &#123;</span><br><span class=line>  gulp.watch(imgSrc, images);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>gulp.task(&apos;watch&apos;,watch);</span><br></pre></td></tr></table></figure><p>watch任务运行时会将文件保存在内存中，并且在watch任务退出时删除。所以这只会在watch任务执行期间节省images任务的时间。</p><p>如果想要比较两次修改之间的变化，那么就需要使用gulp-changed和gulp-newer两个插件。两者的区别就是gulp-changed通过比较文件的生成和修改的时间，只会将修改过的文件发往下个流，如果后续存在文件合并则会出现文件缺失。所以gulp-changed只适合<strong>一对一</strong>的操作。而如果有<strong>多对一</strong>的情况，则需要使用gulp-newer。</p><h2 id=gulp-changed><a href=#gulp-changed class=headerlink title=gulp-changed></a>gulp-changed</h2><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>function images() &#123;</span><br><span class=line>  return gulp.src(imgSrc)</span><br><span class=line>    .pipe(changed(imgDest))  //只把发生改变或新添加的图片文件发向下个流</span><br><span class=line>    .pipe(imagemin(&#123;optimizationLevel: 5&#125;))</span><br><span class=line>    .pipe(gulp.dest(imgDest));</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果文件输出的类型有所不同（sass===&gt;css）需要加上extension参数{extension:’.css’}<br>gulp-changed是基于文件的更改，所以不一定需要使用gulp.watch(),连续使用gulp images命令效果是一样的。<br>gulp-changed只支持<strong>一对一</strong>的文件更新，类似gulp-concat这样合并文件的操作，会有文件内容缺失。</p></blockquote><h2 id=gulp-newer><a href=#gulp-newer class=headerlink title=gulp-newer></a>gulp-newer</h2><h3 id=1-1输出><a href=#1-1输出 class=headerlink title=1:1输出></a>1:1输出</h3><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>function images() &#123;</span><br><span class=line>  return gulp.src(imgSrc)</span><br><span class=line>    .pipe(newer(imgDest))  </span><br><span class=line>    .pipe(imagemin(&#123;optimizationLevel: 5&#125;))</span><br><span class=line>    .pipe(gulp.dest(imgDest));</span><br><span class=line>&#125;</span><br></pre></td></tr></table></figure><h3 id=many-1输出><a href=#many-1输出 class=headerlink title=many:1输出></a>many:1输出</h3><p>类似gulp-concat这样的插件将多个文件合并成一个。在这种情况下，gulp-newer会把流通过所有文件，如果任何一个文件被更新，gulp-newer就会把他输出到下个流。</p><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><span class=line>gulp.task(&apos;concat&apos;, function() &#123;</span><br><span class=line>  return gulp.src(&apos;lib/*.js&apos;)</span><br><span class=line>      .pipe(newer(&apos;dist/all.js&apos;))</span><br><span class=line>      .pipe(concat(&apos;all.js&apos;))</span><br><span class=line>      .pipe(gulp.dest(&apos;dist&apos;));</span><br><span class=line>&#125;);</span><br></pre></td></tr></table></figure><h2 id=gulp-cached><a href=#gulp-cached class=headerlink title=gulp-cached></a>gulp-cached</h2><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line>function images() &#123;</span><br><span class=line>  return gulp.src(imgSrc)</span><br><span class=line>    .pipe(cache(&apos;imageMin&apos;))</span><br><span class=line>    .pipe(imagemin(&#123;optimizationLevel: 5&#125;))</span><br><span class=line>    .pipe(gulp.dest(imgDest));</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>function watch() &#123;</span><br><span class=line>  gulp.watch(imgSrc, images);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>gulp.task(&apos;watch&apos;,watch);</span><br></pre></td></tr></table></figure><blockquote><p>gulp-cached基于保存在内存里的数据的对比，关闭了gulp.watch()就没办法对比文件更新。<br>gulp-cached只会把发生改变的文件发往下个流，如果在流的后期需要对所有文件进行操作，那么就需要gulp-remember的配合。</p></blockquote><h2 id=gulp-remember><a href=#gulp-remember class=headerlink title=gulp-remember></a>gulp-remember</h2><blockquote><p>gulp-remember可以将保存在内存中的所有文件都发向下个流<br>gulp-remember配合使用gulp-cached，可以方便处理当你只想重建那些改变了的文件，但仍然需要对流中的所有文件进行操作的情况。</p></blockquote><p>下面这个案例就是将所有文件合并成一个文件的情况，流的前期用gulp-cached导出那些被修改的文件，后期使用gulp-remember将所有文件导向下个流进行合并操作。</p><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br></pre></td><td class=code><pre><span class=line>var gulp = require(&apos;gulp&apos;),</span><br><span class=line>    header = require(&apos;gulp-header&apos;),</span><br><span class=line>    footer = require(&apos;gulp-footer&apos;),</span><br><span class=line>    concat = require(&apos;gulp-concat&apos;),</span><br><span class=line>    cache = require(&apos;gulp-cached&apos;),</span><br><span class=line>    remember = require(&apos;gulp-remember&apos;);</span><br><span class=line></span><br><span class=line>var scriptsGlob = &apos;src/**/*.js&apos;;</span><br><span class=line></span><br><span class=line>function scripts()&#123;</span><br><span class=line>  return gulp.src(scriptsGlob)</span><br><span class=line>      .pipe(cache(&apos;scripts&apos;)) // 只通过发生改变的文件</span><br><span class=line>      .pipe(header(&apos;(function () &#123;&apos;)) // 在文件头部添加代码&apos;(function () &#123;&apos;</span><br><span class=line>      .pipe(footer(&apos;&#125;)();&apos;)) // 在文件尾部添加代码&apos;&#125;)();&apos;</span><br><span class=line>      .pipe(remember(&apos;scripts&apos;)) // 将所有文件‘召唤’回这个流，其中一些已经被header和footer处理过</span><br><span class=line>      .pipe(concat(&apos;app.js&apos;)) // 合并文件</span><br><span class=line>      .pipe(gulp.dest(&apos;public/&apos;))</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>function watch()&#123;</span><br><span class=line>  var watcher = gulp.watch(scriptsGlob, scripts); </span><br><span class=line>  watcher.on(&apos;change&apos;, function (event) &#123;</span><br><span class=line>    if (event.type === &apos;deleted&apos;) &#123; </span><br><span class=line>      delete cache.caches[&apos;scripts&apos;][event.path];</span><br><span class=line>      remember.forget(&apos;scripts&apos;, event.path);</span><br><span class=line>    &#125;</span><br><span class=line>  &#125;);</span><br><span class=line>&#125;</span><br><span class=line></span><br><span class=line>gulp.task(&apos;watch&apos;,watch);</span><br></pre></td></tr></table></figure><h1 id=使用效果><a href=#使用效果 class=headerlink title=使用效果></a>使用效果</h1><p>未开启增量编译</p><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line>[18:35:26] Using gulpfile D:\blog\gulpfile.js</span><br><span class=line>[18:35:26] Starting &apos;default&apos;...</span><br><span class=line>[18:35:26] Starting &apos;minifyJS&apos;...</span><br><span class=line>[18:35:26] Starting &apos;minifyHtml&apos;...</span><br><span class=line>[18:35:26] Starting &apos;minifyCss&apos;...</span><br><span class=line>[18:35:26] Starting &apos;minifyImgs&apos;...</span><br><span class=line>[18:35:28] Finished &apos;minifyJS&apos; after 2.2 s</span><br><span class=line>[18:35:29] gulp-imagemin: Minified 17 images (saved 0 B - 0%)</span><br><span class=line>[18:35:29] Finished &apos;minifyImgs&apos; after 3.32 s</span><br><span class=line>[18:35:29] Finished &apos;minifyCss&apos; after 3.66 s</span><br><span class=line>[18:35:30] Finished &apos;minifyHtml&apos; after 4.44 s</span><br><span class=line>[18:35:30] Finished &apos;default&apos; after 4.45 s</span><br></pre></td></tr></table></figure><p>开启增量编译</p><figure class="highlight plain"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br></pre></td><td class=code><pre><span class=line>[18:41:27] Using gulpfile D:\blog\gulpfile.js</span><br><span class=line>[18:41:27] Starting &apos;default&apos;...</span><br><span class=line>[18:41:27] Starting &apos;minifyJS&apos;...</span><br><span class=line>[18:41:27] Starting &apos;minifyHtml&apos;...</span><br><span class=line>[18:41:27] Starting &apos;minifyCss&apos;...</span><br><span class=line>[18:41:27] Starting &apos;minifyImgs&apos;...</span><br><span class=line>[18:41:28] Finished &apos;minifyJS&apos; after 879 ms</span><br><span class=line>[18:41:28] gulp-imagemin: Minified 0 images</span><br><span class=line>[18:41:28] Finished &apos;minifyImgs&apos; after 889 ms</span><br><span class=line>[18:41:28] Finished &apos;minifyCss&apos; after 897 ms</span><br><span class=line>[18:41:28] Finished &apos;minifyHtml&apos; after 912 ms</span><br><span class=line>[18:41:28] Finished &apos;default&apos; after 916 ms</span><br></pre></td></tr></table></figure></div><section class=post-copyright><p class=copyright-item><span>Author:</span> <span>jianjian</span></p><p class=copyright-item><span>Permalink:</span> <span><a href="http://yoursite.com/2018/01/31/gulp4%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/">http://yoursite.com/2018/01/31/gulp4%E5%A2%9E%E9%87%8F%E7%BC%96%E8%AF%91/</a></span></p><p class=copyright-item><span>License:</span> <span>Copyright (c) 2019 <a href="http://creativecommons.org/licenses/by-nc/4.0/" target=_blank rel=noopener>CC-BY-NC-4.0</a> LICENSE</span></p><p class=copyright-item><span>Slogan:</span> <span>Do you believe in <strong>DESTINY<strong>?</strong></strong></span></p></section><section class=post-tags><div><span>Tag(s):</span> <span class=tag><a href="/tags/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"># 前端构建工具</a></span></div><div><a href=javascript:window.history.back(); target=_blank rel=noopener>back</a> <span>·</span> <a href="/">home</a></div></section><section class=post-nav><a class=prev rel=prev href="/2018/02/08/%E7%94%A8%E4%B8%80%E4%B8%AAhello%20world%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0webpack/">用一个hello world项目学习webpack</a> <a class=next rel=next href="/2018/01/25/%E9%9B%B6%E9%85%8D%E7%BD%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%EF%BC%9Aparcel/">零配置构建工具：parcel</a></section></article></div></div><footer id=footer class=footer><div class=copyright><span>© jianjian | Powered by <a href=https://hexo.io target=_blank>Hexo</a> & <a href=https://github.com/Siricee/hexo-theme-Chic target=_blank>Chic</a></span></div></footer></div></body></html>